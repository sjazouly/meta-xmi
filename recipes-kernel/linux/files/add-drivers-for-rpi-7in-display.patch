diff --git a/drivers/gpu/drm/bridge/Kconfig b/drivers/gpu/drm/bridge/Kconfig
index 34cc027f8b390..f53e0c413be00 100644
--- a/drivers/gpu/drm/bridge/Kconfig
+++ b/drivers/gpu/drm/bridge/Kconfig
@@ -347,6 +347,15 @@ config DRM_TOSHIBA_TC358775
 	help
 	  Toshiba TC358775 DSI/LVDS bridge chip driver.
 
+config DRM_TOSHIBA_TC358867XBG
+	tristate "Toshiba TC358867XBG DSI to DPI bridge"
+	depends on OF
+	select DRM_MIPI_DSI
+	select DRM_KMS_HELPER
+	select DRM_PANEL
+	help
+	  Toshiba TC358867XBG DSI to DPI bridge driver.
+
 config DRM_TI_DLPC3433
 	tristate "TI DLPC3433 Display controller"
 	depends on DRM && DRM_PANEL
diff --git a/drivers/gpu/drm/bridge/Makefile b/drivers/gpu/drm/bridge/Makefile
index f466d131a78af..5f3a0a312c659 100644
--- a/drivers/gpu/drm/bridge/Makefile
+++ b/drivers/gpu/drm/bridge/Makefile
@@ -26,6 +26,7 @@ obj-$(CONFIG_DRM_TOSHIBA_TC358764) += tc358764.o
 obj-$(CONFIG_DRM_TOSHIBA_TC358767) += tc358767.o
 obj-$(CONFIG_DRM_TOSHIBA_TC358768) += tc358768.o
 obj-$(CONFIG_DRM_TOSHIBA_TC358775) += tc358775.o
+obj-$(CONFIG_DRM_TOSHIBA_TC358867XBG) += tc358867xbg.o
 obj-$(CONFIG_DRM_I2C_ADV7511) += adv7511/
 obj-$(CONFIG_DRM_TI_DLPC3433) += ti-dlpc3433.o
 obj-$(CONFIG_DRM_TI_SN65DSI83) += ti-sn65dsi83.o
diff --git a/drivers/gpu/drm/bridge/tc358867xbg.c b/drivers/gpu/drm/bridge/tc358867xbg.c
new file mode 100644
index 0000000000000..fd32b4f51f4e3
--- /dev/null
+++ b/drivers/gpu/drm/bridge/tc358867xbg.c
@@ -0,0 +1,392 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 Markus Bauer <MB@karo-electronics.de>
+ *
+ * based on: drivers/gpu/drm/panel/panel-rpi-7inch.c
+ * and: drivers/gpu/drm/bridge/tc358767.c
+ */
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/media-bus-format.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_crtc.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_print.h>
+#include <drm/rpi_display.h>
+
+#include <video/display_timing.h>
+#include <video/of_display_timing.h>
+#include <video/videomode.h>
+#include <video/of_videomode.h>
+
+// Basic Registers
+#define POCTRL			0x0448
+#define DP0_SRCCTRL		0x06a0
+#define PXL_PLLPARAM		0x0914
+#define PXL_PLLCTRL		0x0908
+#define SYS_PLLPARAM		0x0918
+#define DP_PHY_CTRL		0x0800
+#define PPI_TX_RX_TA		0x013c
+#define LPTXTIMCNT		0x0114
+#define D0S_CLRSIPOCOUNT	0x0164
+#define D1S_CLRSIPOCOUNT	0x0168
+#define D2S_CLRSIPOCOUNT	0x016c
+#define D3S_CLRSIPOCOUNT	0x0170
+#define PPI_LANEENABLE		0x0134
+#define DSI_LANEENABLE		0x0210
+#define STARTPPI		0x0104
+#define STARTDSI		0x0204
+
+// Timing Registers
+#define VPCTRL			0x0450
+#define HTIM01			0x0454
+#define VTIM01			0x045c
+#define VFUEN0			0x0464
+#define SYSCTRL			0x0510
+
+// Panel for DRM
+struct panel_desc {
+	const struct drm_display_mode *modes;
+	unsigned int num_modes;
+	const struct display_timing *timings;
+	unsigned int num_timings;
+
+	unsigned int bpc;
+
+	struct {
+		unsigned int width;
+		unsigned int height;
+	} size;
+
+	u32 bus_format;
+};
+
+struct tc358867 {
+	struct drm_panel base;
+	bool enabled;
+
+	struct device *dev;
+	struct mipi_dsi_device *dsi;
+	const struct panel_desc *desc;
+};
+
+static const struct drm_display_mode tc358867_default_mode = {
+	.clock = 25175,
+	.hdisplay = 800,
+	.hsync_start = 800 + 40,
+	.hsync_end = 800 + 40 + 128,
+	.htotal = 800 + 40 + 128 + 88,
+	.vdisplay = 480,
+	.vsync_start = 480 + 10,
+	.vsync_end = 480 + 10 + 2,
+	.vtotal = 480 + 10 + 2 + 33,
+	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+};
+
+static inline struct tc358867 *to_tc358867(struct drm_panel *panel)
+{
+	return container_of(panel, struct tc358867, base);
+}
+
+static int tc358867_disable(struct drm_panel *panel)
+{
+	struct tc358867 *p = to_tc358867(panel);
+
+	if (!p->enabled)
+		return 0;
+
+	pr_debug("disable panel\n");
+
+	p->enabled = false;
+
+	return 0;
+}
+
+static int tc358867_mipi_write(struct mipi_dsi_device *dsi, u16 reg, u32 val)
+{
+	u8 msg[] = {
+		reg,
+		reg >> 8,
+		val,
+		val >> 8,
+		val >> 16,
+		val >> 24,
+	};
+
+	mipi_dsi_generic_write(dsi, msg, sizeof(msg));
+
+	return 0;
+}
+
+static int tc358867_dsi_init(struct tc358867 *p)
+{
+	struct mipi_dsi_device *dsi = p->dsi;
+
+	// initialize bridge
+	tc358867_mipi_write(dsi, POCTRL, 0x8e);
+	tc358867_mipi_write(dsi, DP0_SRCCTRL, 0x3080);
+	tc358867_mipi_write(dsi, PXL_PLLPARAM, 0x128301);
+	tc358867_mipi_write(dsi, PXL_PLLCTRL, 0x1);
+	msleep(100);
+	tc358867_mipi_write(dsi, PXL_PLLCTRL, 0x5);
+	tc358867_mipi_write(dsi, SYS_PLLPARAM, 0x110);
+	tc358867_mipi_write(dsi, DP_PHY_CTRL, 0x1100);
+	tc358867_mipi_write(dsi, PPI_TX_RX_TA, 0x08000b);
+	tc358867_mipi_write(dsi, LPTXTIMCNT, 0x7);
+	tc358867_mipi_write(dsi, D0S_CLRSIPOCOUNT, 0xd);
+	tc358867_mipi_write(dsi, D1S_CLRSIPOCOUNT, 0xd);
+	tc358867_mipi_write(dsi, D2S_CLRSIPOCOUNT, 0xd);
+	tc358867_mipi_write(dsi, D3S_CLRSIPOCOUNT, 0xd);
+	tc358867_mipi_write(dsi, PPI_LANEENABLE, 0x3);
+	tc358867_mipi_write(dsi, DSI_LANEENABLE, 0x3);
+	tc358867_mipi_write(dsi, STARTPPI, 0x1);
+	tc358867_mipi_write(dsi, STARTDSI, 0x1);
+	tc358867_mipi_write(dsi, VPCTRL, 0xa00100);
+	tc358867_mipi_write(dsi, HTIM01, 0x2f001f);
+	tc358867_mipi_write(dsi, VTIM01, 0x30004);
+	tc358867_mipi_write(dsi, VFUEN0, 0x1);
+	tc358867_mipi_write(dsi, SYSCTRL, 0x1);
+
+	return 0;
+}
+
+static int tc358867_enable(struct drm_panel *panel)
+{
+	struct tc358867 *p = to_tc358867(panel);
+
+	if (p->enabled)
+		return 0;
+
+	pr_debug("panel enable\n");
+
+	tc358867_dsi_init(p);
+
+	p->enabled = true;
+
+	return 0;
+}
+
+static int tc358867_get_modes(struct drm_panel *panel, struct drm_connector *connector)
+{
+	struct drm_display_mode *mode = drm_mode_create(connector->dev);
+	u32 bus_flags = 0;
+
+	/* Take default timing if there is not device tree node for */
+	if (of_get_drm_display_mode(panel->dev->of_node, mode, &bus_flags, 0) < 0) {
+		mode = drm_mode_duplicate(connector->dev, &tc358867_default_mode);
+		if (!mode) {
+			DRM_ERROR("failed to add mode %ux%ux\n",
+				tc358867_default_mode.hdisplay, tc358867_default_mode.vdisplay);
+			return -ENOMEM;
+		}
+	}
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	drm_mode_probed_add(connector, mode);
+
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+
+	return 1;
+}
+
+static int tc358867_get_timings(struct drm_panel *panel,
+				unsigned int num_timings,
+				struct display_timing *timings)
+{
+	struct tc358867 *p = to_tc358867(panel);
+	unsigned int i;
+
+	if (!p->desc)
+		return 0;
+
+	if (p->desc->num_timings < num_timings)
+		num_timings = p->desc->num_timings;
+
+	if (timings)
+		for (i = 0; i < num_timings; i++)
+			timings[i] = p->desc->timings[i];
+
+	return p->desc->num_timings;
+}
+
+static const struct drm_panel_funcs tc358867_funcs = {
+	.disable = tc358867_disable,
+	.enable = tc358867_enable,
+	.get_modes = tc358867_get_modes,
+	.get_timings = tc358867_get_timings,
+};
+
+static int tc358867_mipi_probe(struct mipi_dsi_device *dsi, const struct panel_desc *desc)
+{
+	struct tc358867 *panel;
+	struct device *dev = &dsi->dev;
+	int err;
+
+	panel = devm_kzalloc(dev, sizeof(*panel), GFP_KERNEL);
+	if (!panel)
+		return -ENOMEM;
+
+	panel->enabled = false;
+	panel->desc = desc;
+	panel->dev = dev;
+	panel->dsi = dsi;
+
+	drm_panel_init(&panel->base, dev, &tc358867_funcs, DRM_MODE_CONNECTOR_DSI);
+	panel->base.dev = dev;
+	panel->base.funcs = &tc358867_funcs;
+
+	drm_panel_add(&panel->base);
+
+	dev_set_drvdata(dev, panel);
+
+	return 0;
+}
+
+static int tc358867_remove(struct device *dev)
+{
+	struct tc358867 *panel = dev_get_drvdata(dev);
+
+	drm_panel_remove(&panel->base);
+
+	tc358867_disable(&panel->base);
+
+	return 0;
+}
+
+static void tc358867_shutdown(struct device *dev)
+{
+	struct tc358867 *panel = dev_get_drvdata(dev);
+
+	tc358867_disable(&panel->base);
+}
+
+struct bridge_desc {
+	struct panel_desc desc;
+
+	unsigned long flags;
+	enum mipi_dsi_pixel_format format;
+	unsigned int lanes;
+};
+
+static const struct bridge_desc tc358867_bridge = {
+	.desc = {
+		.modes = &tc358867_default_mode,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 154,
+			.height = 86,
+		},
+		.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
+	},
+	.flags = MIPI_DSI_MODE_VIDEO |
+		 MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
+		 MIPI_DSI_MODE_LPM,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 1,
+};
+
+static const struct of_device_id dsi_of_match[] = {
+	{
+		.compatible = "toshiba,tc358867xbg",
+		.data = &tc358867_bridge
+	},
+	{
+		/* sentinel */
+	}
+};
+MODULE_DEVICE_TABLE(of, dsi_of_match);
+
+static int tc358867_dsi_probe(struct mipi_dsi_device *dsi)
+{
+	const struct bridge_desc *desc;
+	const struct of_device_id *id;
+	const struct panel_desc *pdesc;
+	u32 val;
+	int err;
+
+	id = of_match_node(dsi_of_match, dsi->dev.of_node);
+	if (!id)
+		return -ENODEV;
+
+	desc = id->data;
+
+	if (desc) {
+		dsi->mode_flags = desc->flags;
+		dsi->format = desc->format;
+		dsi->lanes = desc->lanes;
+		pdesc = &desc->desc;
+	} else {
+		pdesc = NULL;
+	}
+
+	err = tc358867_mipi_probe(dsi, pdesc);
+
+	if (err < 0)
+		return err;
+
+	return mipi_dsi_attach(dsi);
+}
+
+static void tc358867_dsi_remove(struct mipi_dsi_device *dsi)
+{
+	int err;
+//	int ret;
+
+	err = mipi_dsi_detach(dsi);
+	if (err < 0)
+		dev_err(&dsi->dev, "failed to detach from DSI host: %d\n", err);
+
+//	return tc358867_remove(&dsi->dev);
+	tc358867_remove(&dsi->dev);
+	return;
+}
+
+static void tc358867_dsi_shutdown(struct mipi_dsi_device *dsi)
+{
+	tc358867_shutdown(&dsi->dev);
+}
+
+static struct mipi_dsi_driver tc358867_dsi_driver = {
+	.driver = {
+		.name = "tc358867",
+		.of_match_table = dsi_of_match,
+	},
+	.probe = tc358867_dsi_probe,
+	.remove = tc358867_dsi_remove,
+	.shutdown = tc358867_dsi_shutdown,
+};
+
+static int __init tc358867_init(void)
+{
+	int err;
+
+	if (IS_ENABLED(CONFIG_DRM_MIPI_DSI)) {
+		err = mipi_dsi_driver_register(&tc358867_dsi_driver);
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+module_init(tc358867_init);
+
+static void __exit tc358867_exit(void)
+{
+	if (IS_ENABLED(CONFIG_DRM_MIPI_DSI))
+		mipi_dsi_driver_unregister(&tc358867_dsi_driver);
+}
+module_exit(tc358867_exit);
+
+MODULE_AUTHOR("Markus Bauer <mb@karo-electronics.com>");
+MODULE_DESCRIPTION("DRM Driver for toshiba tc358867xbg DSI to DPI Bridge");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index c9311213c2d19..82263ab94851c 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -425,6 +425,17 @@ config DRM_PANEL_RASPBERRYPI_TOUCHSCREEN
 	  Say Y here if you want to enable support for the Raspberry
 	  Pi 7" Touchscreen.  To compile this driver as a module,
 	  choose M here.
+	  
+config DRM_PANEL_RPI_7INCH
+	tristate "Ka-Ro electronics RaspberryPi 7inch display panel driver"
+	depends on OF && I2C
+	depends on DRM_MIPI_DSI
+	select RPI_DISPLAY
+	select TOUCHSCREEN_RPI_FT5406
+	select VIDEOMODE_HELPERS
+	help
+	  Say Y here if you want to enable support for the official RaspberryPi 7inch panel.
+
 
 config DRM_PANEL_RAYDIUM_RM67191
 	tristate "Raydium RM67191 FHD 1080x1920 DSI video mode panel"
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index 1c82b1a0d6004..d1f9e5b9ad701 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -40,6 +40,7 @@ obj-$(CONFIG_DRM_PANEL_ORISETECH_OTM8009A) += panel-orisetech-otm8009a.o
 obj-$(CONFIG_DRM_PANEL_OSD_OSD101T2587_53TS) += panel-osd-osd101t2587-53ts.o
 obj-$(CONFIG_DRM_PANEL_PANASONIC_VVX10F034N00) += panel-panasonic-vvx10f034n00.o
 obj-$(CONFIG_DRM_PANEL_RASPBERRYPI_TOUCHSCREEN) += panel-raspberrypi-touchscreen.o
+obj-$(CONFIG_DRM_PANEL_RPI_7INCH) += panel-rpi-7inch.o
 obj-$(CONFIG_DRM_PANEL_RAYDIUM_RM67191) += panel-raydium-rm67191.o
 obj-$(CONFIG_DRM_PANEL_RAYDIUM_RM68200) += panel-raydium-rm68200.o
 obj-$(CONFIG_DRM_PANEL_ROCKTECK_HIMAX8394F) += panel-rocktech-hx8394f.o
diff --git a/drivers/gpu/drm/panel/panel-rpi-7inch.c b/drivers/gpu/drm/panel/panel-rpi-7inch.c
new file mode 100644
index 0000000000000..cf16bec547a86
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-rpi-7inch.c
@@ -0,0 +1,523 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2020 Markus Bauer <MB@karo-electronics.de>
+ *
+ * based on: drivers/gpu/drm/panel/panel-rpi-7inch.c
+ * from: https://github.com/TinkerEdgeT/mendel-linux-imx
+ *
+ * Copyright (C) 2013, NVIDIA Corporation.  All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/media-bus-format.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_crtc.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_print.h>
+#include <drm/rpi_display.h>
+
+#include <video/display_timing.h>
+#include <video/of_display_timing.h>
+#include <video/videomode.h>
+
+/* DSI PPI Layer Registers */
+#define PPI_STARTPPI		0x0104
+#define PPI_LPTXTIMECNT		0x0114
+#define PPI_D0S_ATMR		0x0144
+#define PPI_D1S_ATMR		0x0148
+#define PPI_D0S_CLRSIPOCOUNT	0x0164
+#define PPI_D1S_CLRSIPOCOUNT	0x0168
+
+/* DSI Protocol Layer Registers */
+#define DSI_STARTDSI		0x0204
+#define DSI_BUSYDSI		0x0208
+#define DSI_LANEENABLE		0x0210
+#define DSI_LANEENABLE_CLOCK	BIT(0)
+#define DSI_LANEENABLE_D0	BIT(1)
+#define DSI_LANEENABLE_D1	BIT(2)
+
+/* LCDC/DPI Host Registers */
+#define LCDCTRL			0x0420
+
+/* SPI Master Registers */
+#define SPICMR			0x0450
+
+/* System Controller Registers */
+#define SYSCTRL			0x0464
+
+static int trigger_bridge = 1;
+
+struct panel_desc {
+	const struct drm_display_mode *modes;
+	unsigned int num_modes;
+	const struct display_timing *timings;
+	unsigned int num_timings;
+
+	unsigned int bpc;
+
+	struct {
+		unsigned int width;
+		unsigned int height;
+	} size;
+
+	/**
+	 * @prepare: the time (in milliseconds) that it takes for the panel to
+	 *		become ready and start receiving video data
+	 * @enable: the time (in milliseconds) that it takes for the panel to
+	 *		display the first valid frame after starting to receive
+	 *		video data
+	 * @disable: the time (in milliseconds) that it takes for the panel to
+	 *		turn the display off (no content is visible)
+	 * @unprepare: the time (in milliseconds) that it takes for the panel
+	 *		to power itself down completely
+	 */
+	struct {
+		unsigned int prepare;
+		unsigned int enable;
+		unsigned int disable;
+		unsigned int unprepare;
+	} delay;
+
+	u32 bus_format;
+};
+
+struct tc358762 {
+	struct drm_panel base;
+	bool prepared;
+	bool enabled;
+
+	struct device *dev;
+	struct mipi_dsi_device *dsi;
+	const struct panel_desc *desc;
+
+	struct regulator *supply;
+
+	struct gpio_desc *enable_gpio;
+};
+
+static const struct drm_display_mode tc358762_mode = {
+	.clock = 27448,
+	.hdisplay = 800,
+	.hsync_start = 800 + 70,
+	.hsync_end = 800 + 70 + 20,
+	.htotal = 800 + 70 + 20 + 23,
+	.vdisplay = 480,
+	.vsync_start = 480 + 7,
+	.vsync_end = 480 + 7 + 2,
+	.vtotal = 480 + 7 + 2 + 21,
+	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
+};
+
+static inline struct tc358762 *to_tc358762(struct drm_panel *panel)
+{
+	return container_of(panel, struct tc358762, base);
+}
+
+static int tc358762_disable(struct drm_panel *panel)
+{
+	struct tc358762 *p = to_tc358762(panel);
+
+	if (!p->enabled)
+		return 0;
+
+	pr_debug("panel disable\n");
+
+	rpi_display_set_bright(0x00);
+
+	if (p->desc && p->desc->delay.disable)
+		msleep(p->desc->delay.disable);
+
+	p->enabled = false;
+
+	return 0;
+}
+
+static int tc358762_unprepare(struct drm_panel *panel)
+{
+	struct tc358762 *p = to_tc358762(panel);
+
+	if (!p->prepared)
+		return 0;
+
+	if (p->enable_gpio)
+		gpiod_direction_output(p->enable_gpio, 0);
+
+	regulator_disable(p->supply);
+
+	if (p->desc && p->desc->delay.unprepare)
+		msleep(p->desc->delay.unprepare);
+
+	p->prepared = false;
+
+	return 0;
+}
+
+static int rpi_touchscreen_write(struct mipi_dsi_device *dsi, u16 reg, u32 val)
+{
+	u8 msg[] = {
+		reg,
+		reg >> 8,
+		val,
+		val >> 8,
+		val >> 16,
+		val >> 24,
+	};
+
+	mipi_dsi_generic_write(dsi, msg, sizeof(msg));
+
+	return 0;
+}
+
+static int tc358762_dsi_init(struct tc358762 *p)
+{
+	struct mipi_dsi_device *dsi = p->dsi;
+
+	rpi_touchscreen_write(dsi, DSI_LANEENABLE,
+			      DSI_LANEENABLE_CLOCK |
+			      DSI_LANEENABLE_D0);
+
+	rpi_touchscreen_write(dsi, PPI_D0S_CLRSIPOCOUNT, 0x05);
+	rpi_touchscreen_write(dsi, PPI_D1S_CLRSIPOCOUNT, 0x05);
+	rpi_touchscreen_write(dsi, PPI_D0S_ATMR, 0x00);
+	rpi_touchscreen_write(dsi, PPI_D1S_ATMR, 0x00);
+	rpi_touchscreen_write(dsi, PPI_LPTXTIMECNT, 0x03);
+
+	rpi_touchscreen_write(dsi, SPICMR, 0x00);
+	rpi_touchscreen_write(dsi, LCDCTRL, 0x00100150);
+	rpi_touchscreen_write(dsi, SYSCTRL, 0x040f);
+	msleep(100);
+
+	rpi_touchscreen_write(dsi, PPI_STARTPPI, 0x01);
+	rpi_touchscreen_write(dsi, DSI_STARTDSI, 0x01);
+	msleep(100);
+
+	return 0;
+}
+
+static int tc358762_prepare(struct drm_panel *panel)
+{
+	struct tc358762 *p = to_tc358762(panel);
+	int err;
+
+	if (p->prepared)
+		return 0;
+
+	err = regulator_enable(p->supply);
+	if (err < 0) {
+		dev_err(panel->dev, "failed to enable supply: %d\n", err);
+		return err;
+	}
+
+	if (p->enable_gpio)
+		gpiod_direction_output(p->enable_gpio, 1);
+
+	if (p->desc && p->desc->delay.prepare)
+		msleep(p->desc->delay.prepare);
+
+	p->prepared = true;
+
+	return 0;
+}
+
+static int tc358762_enable(struct drm_panel *panel)
+{
+	struct tc358762 *p = to_tc358762(panel);
+
+	if (p->enabled)
+		return 0;
+
+	pr_debug("panel enable\n");
+
+	if (trigger_bridge) {
+		pr_debug("rpi_display_power_up");
+		rpi_display_screen_power_up();
+		trigger_bridge = 0;
+		msleep(100);
+		pr_debug("rpi_ft5406_start_polling");
+		rpi_ft5406_start_polling();
+	}
+
+	tc358762_dsi_init(p);
+
+	rpi_display_set_bright(0xFF);
+
+	p->enabled = true;
+
+	return 0;
+}
+
+static int tc358762_get_modes(struct drm_panel *panel, struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &tc358762_mode);
+	if (!mode) {
+		DRM_ERROR("failed to add mode %ux%ux\n",
+			  tc358762_mode.hdisplay, tc358762_mode.vdisplay);
+		return -ENOMEM;
+	}
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	drm_mode_probed_add(connector, mode);
+
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+
+	return 1;
+}
+
+static int tc358762_get_timings(struct drm_panel *panel,
+				unsigned int num_timings,
+				struct display_timing *timings)
+{
+	struct tc358762 *p = to_tc358762(panel);
+	unsigned int i;
+
+	if (!p->desc)
+		return 0;
+
+	if (p->desc->num_timings < num_timings)
+		num_timings = p->desc->num_timings;
+
+	if (timings)
+		for (i = 0; i < num_timings; i++)
+			timings[i] = p->desc->timings[i];
+
+	return p->desc->num_timings;
+}
+
+static const struct drm_panel_funcs tc358762_funcs = {
+	.disable = tc358762_disable,
+	.unprepare = tc358762_unprepare,
+	.prepare = tc358762_prepare,
+	.enable = tc358762_enable,
+	.get_modes = tc358762_get_modes,
+	.get_timings = tc358762_get_timings,
+};
+
+static int tc358762_mipi_probe(struct mipi_dsi_device *dsi, const struct panel_desc *desc)
+{
+	struct tc358762 *panel;
+	struct device *dev = &dsi->dev;
+	int err;
+
+	panel = devm_kzalloc(dev, sizeof(*panel), GFP_KERNEL);
+	if (!panel)
+		return -ENOMEM;
+
+	panel->enabled = false;
+	panel->prepared = false;
+	panel->desc = desc;
+	panel->dev = dev;
+	panel->dsi = dsi;
+
+	panel->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(panel->supply))
+		return PTR_ERR(panel->supply);
+
+	panel->enable_gpio = devm_gpiod_get_optional(dev, "enable",
+							 GPIOD_OUT_LOW);
+	if (IS_ERR(panel->enable_gpio)) {
+		err = PTR_ERR(panel->enable_gpio);
+		dev_err(dev, "failed to request GPIO: %d\n", err);
+		return err;
+	}
+
+	drm_panel_init(&panel->base, dev, &tc358762_funcs, DRM_MODE_CONNECTOR_DSI);
+	panel->base.dev = dev;
+	panel->base.funcs = &tc358762_funcs;
+
+	drm_panel_add(&panel->base);
+
+	dev_set_drvdata(dev, panel);
+
+	return 0;
+}
+
+static int tc358762_remove(struct device *dev)
+{
+	struct tc358762 *panel = dev_get_drvdata(dev);
+
+	drm_panel_remove(&panel->base);
+
+	tc358762_disable(&panel->base);
+
+	return 0;
+}
+
+static void tc358762_shutdown(struct device *dev)
+{
+	struct tc358762 *panel = dev_get_drvdata(dev);
+
+	tc358762_disable(&panel->base);
+}
+
+struct bridge_desc {
+	struct panel_desc desc;
+
+	unsigned long flags;
+	enum mipi_dsi_pixel_format format;
+	unsigned int lanes;
+};
+
+static const struct bridge_desc tc358762_bridge = {
+	.desc = {
+		.modes = &tc358762_mode,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 154,
+			.height = 86,
+		},
+		.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
+	},
+	.flags = MIPI_DSI_MODE_VIDEO |
+		 MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
+		 MIPI_DSI_MODE_LPM |
+		 MIPI_DSI_MODE_VIDEO_HSE,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 1,
+};
+
+static const struct of_device_id dsi_of_match[] = {
+	{
+		.compatible = "raspberrypi,tc358762",
+		.data = &tc358762_bridge
+	},
+	{
+		/*
+		 * keep the unofficial 'rpi' vendor prefix for
+		 * compatibility with existing dtbs
+		 */
+		.compatible = "rpi,tc358762",
+		.data = &tc358762_bridge
+	},
+	{
+		/* sentinel */
+	}
+};
+MODULE_DEVICE_TABLE(of, dsi_of_match);
+
+static int tc358762_dsi_probe(struct mipi_dsi_device *dsi)
+{
+	const struct bridge_desc *desc;
+	const struct of_device_id *id;
+	const struct panel_desc *pdesc;
+	u32 val;
+	int err;
+
+	id = of_match_node(dsi_of_match, dsi->dev.of_node);
+	if (!id)
+		return -ENODEV;
+
+	if (of_device_is_compatible(dsi->dev.of_node, "rpi,tc358762"))
+		dev_warn(&dsi->dev,
+			 "Your DTB needs to be updated to use the official vendor prefix 'raspberrypi' rather than 'rpi'");
+
+	desc = id->data;
+
+	if (desc) {
+		dsi->mode_flags = desc->flags;
+		dsi->format = desc->format;
+		dsi->lanes = desc->lanes;
+		pdesc = &desc->desc;
+	} else {
+		pdesc = NULL;
+	}
+
+	err = tc358762_mipi_probe(dsi, pdesc);
+
+	if (err < 0)
+		return err;
+
+	if (!of_property_read_u32(dsi->dev.of_node, "dsi,flags", &val))
+		dsi->mode_flags = val;
+
+	if (!of_property_read_u32(dsi->dev.of_node, "dsi,format", &val))
+		dsi->format = val;
+
+	if (!of_property_read_u32(dsi->dev.of_node, "dsi,lanes", &val))
+		dsi->lanes = val;
+
+	return mipi_dsi_attach(dsi);
+}
+
+static void tc358762_dsi_remove(struct mipi_dsi_device *dsi)
+{
+	int err;
+
+	err = mipi_dsi_detach(dsi);
+	if (err < 0)
+		dev_err(&dsi->dev, "failed to detach from DSI host: %d\n", err);
+
+//	return tc358762_remove(&dsi->dev);
+	tc358762_remove(&dsi->dev);
+	return;
+}
+
+static void tc358762_dsi_shutdown(struct mipi_dsi_device *dsi)
+{
+	tc358762_shutdown(&dsi->dev);
+}
+
+static struct mipi_dsi_driver tc358762_dsi_driver = {
+	.driver = {
+		.name = "bridge-tc358762-dsi",
+		.of_match_table = dsi_of_match,
+	},
+	.probe = tc358762_dsi_probe,
+	.remove = tc358762_dsi_remove,
+	.shutdown = tc358762_dsi_shutdown,
+};
+
+static int __init tc358762_init(void)
+{
+	int err;
+
+	if (IS_ENABLED(CONFIG_DRM_MIPI_DSI)) {
+		err = mipi_dsi_driver_register(&tc358762_dsi_driver);
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+module_init(tc358762_init);
+
+static void __exit tc358762_exit(void)
+{
+	if (IS_ENABLED(CONFIG_DRM_MIPI_DSI))
+		mipi_dsi_driver_unregister(&tc358762_dsi_driver);
+}
+module_exit(tc358762_exit);
+
+MODULE_AUTHOR("Jerry <xbl@rock-chips.com>");
+MODULE_DESCRIPTION("DRM Driver for toshiba tc358762 Bridge");
+MODULE_LICENSE("GPL and additional rights");
diff --git a/drivers/gpu/drm/panel/panel-simple.c b/drivers/gpu/drm/panel/panel-simple.c
index d437d691556a9..877d8a6f8c22a 100644
--- a/drivers/gpu/drm/panel/panel-simple.c
+++ b/drivers/gpu/drm/panel/panel-simple.c
@@ -3705,6 +3705,31 @@ static const struct panel_desc tianma_tm070rvhg71 = {
 	.connector_type = DRM_MODE_CONNECTOR_LVDS,
 };
 
+
+static const struct display_timing tianma_tm101jvhg32_timing = {
+	.pixelclock = { 62600000, 68200000, 78100000, },
+	.hactive = { 1280, 1280, 1280, },
+	.hfront_porch = { 15, 64, 159, },
+	.hback_porch = { 5, 4, 100, },
+	.hsync_len = { 20, 1, 164, },
+	.vactive = { 800, 800, 800, },
+	.vfront_porch = { 3, 40, 99, },
+	.vback_porch = { 2, 1, 61, },
+	.vsync_len = { 1, 1, 128, },
+	.flags = DISPLAY_FLAGS_DE_HIGH | DISPLAY_FLAGS_HSYNC_LOW | DISPLAY_FLAGS_VSYNC_LOW,
+};
+
+static const struct panel_desc tianma_tm101jvhg32 = {
+	.timings = &tianma_tm101jvhg32_timing,
+	.num_timings = 1,
+	.bpc = 8,
+	.size = {
+		.width = 217,
+		.height = 136,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
+};
+
 static const struct drm_display_mode ti_nspire_cx_lcd_mode[] = {
 	{
 		.clock = 10000,
@@ -4050,6 +4075,10 @@ static const struct of_device_id platform_of_match[] = {
 		.compatible = "avic,tm070ddh03",
 		.data = &avic_tm070ddh03,
 	}, {
+		.compatible = "tianma,tm101jvhg32",
+		.data = &tianma_tm101jvhg32,
+	}, {
+
 		.compatible = "bananapi,s070wv20-ct16",
 		.data = &bananapi_s070wv20_ct16,
 	}, {
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 375726166984f..a4a134c1267d6 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -1321,6 +1321,13 @@ config TOUCHSCREEN_SX8654
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called sx8654.
+	  
+config TOUCHSCREEN_RPI_FT5406
+	tristate "RaspberryPi 7inch touchscreen ft5406"
+	default y
+	depends on I2C
+	help
+	  Controls the official RaspberryPi 7inch ft5406 touch ic.
 
 config TOUCHSCREEN_TPS6507X
 	tristate "TPS6507x based touchscreens"
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 2fd6479510aa6..3b15bb3b07639 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -112,6 +112,7 @@ wm97xx-ts-$(CONFIG_TOUCHSCREEN_WM9713)	+= wm9713.o
 obj-$(CONFIG_TOUCHSCREEN_WM97XX_MAINSTONE)	+= mainstone-wm97xx.o
 obj-$(CONFIG_TOUCHSCREEN_WM97XX_ZYLONITE)	+= zylonite-wm97xx.o
 obj-$(CONFIG_TOUCHSCREEN_SX8654)	+= sx8654.o
+obj-$(CONFIG_TOUCHSCREEN_RPI_FT5406)    += rpi_ft5406.o
 obj-$(CONFIG_TOUCHSCREEN_TPS6507X)	+= tps6507x-ts.o
 obj-$(CONFIG_TOUCHSCREEN_ZET6223)	+= zet6223.o
 obj-$(CONFIG_TOUCHSCREEN_ZFORCE)	+= zforce_ts.o
diff --git a/drivers/input/touchscreen/rpi_ft5406.c b/drivers/input/touchscreen/rpi_ft5406.c
new file mode 100644
index 0000000000000..22689b2f014ee
--- /dev/null
+++ b/drivers/input/touchscreen/rpi_ft5406.c
@@ -0,0 +1,362 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *
+ * RPI Display FT5406 touch driver.
+ *
+ * Copyright (C) 2020 Markus Bauer <MB@karo-electronics.de>
+ *
+ * based on: drivers/input/touchscreen/rpi_ft406.c
+ * from: https://github.com/TinkerEdgeT/mendel-linux-imx
+ *
+ * Copyright (c) 2016 ASUSTek Computer Inc.
+ * Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+ *
+ */
+
+#include <drm/rpi_display.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/input/mt.h>
+#include <linux/module.h>
+#include <linux/workqueue.h>
+#include "rpi_ft5406.h"
+
+static struct rpi_ft5406_data g_ts_data;
+
+static int fts_i2c_read(struct i2c_client *client, char *writebuf,
+			   int writelen, char *readbuf, int readlen)
+{
+	int ret;
+
+	if (writelen > 0) {
+		struct i2c_msg msgs[] = {
+			{
+				 .addr = client->addr,
+				 .flags = 0,
+				 .len = writelen,
+				 .buf = writebuf,
+			 },
+			{
+				 .addr = client->addr,
+				 .flags = I2C_M_RD,
+				 .len = readlen,
+				 .buf = readbuf,
+			 },
+		};
+		ret = i2c_transfer(client->adapter, msgs, 2);
+		if (ret < 0)
+			LOG_ERR("i2c read error, %d\n", ret);
+	} else {
+		struct i2c_msg msgs[] = {
+			{
+				 .addr = client->addr,
+				 .flags = I2C_M_RD,
+				 .len = readlen,
+				 .buf = readbuf,
+			 },
+		};
+		ret = i2c_transfer(client->adapter, msgs, 1);
+		if (ret < 0)
+			LOG_ERR("i2c read error, %d\n", ret);
+	}
+
+	return ret;
+}
+
+static int fts_read_reg(struct i2c_client *client, u8 addr, u8 *val)
+{
+	return fts_i2c_read(client, &addr, 1, val, 1);
+}
+
+static int fts_check_fw_ver(struct i2c_client *client)
+{
+	u8 reg_addr, fw_ver[3];
+	int ret;
+
+	reg_addr = FT_REG_FW_VER;
+	ret = fts_i2c_read(client, &reg_addr, 1, &fw_ver[0], 1);
+	if (ret < 0)
+		goto error;
+
+	reg_addr = FT_REG_FW_MIN_VER;
+	ret = fts_i2c_read(client, &reg_addr, 1, &fw_ver[1], 1);
+	if (ret < 0)
+		goto error;
+
+	reg_addr = FT_REG_FW_SUB_MIN_VER;
+	ret = fts_i2c_read(client, &reg_addr, 1, &fw_ver[2], 1);
+	if (ret < 0)
+		goto error;
+
+	LOG_INFO("Firmware version = %d.%d.%d\n",
+		 fw_ver[0], fw_ver[1], fw_ver[2]);
+	return 0;
+
+error:
+	return ret;
+}
+
+static int fts_read_td_status(struct rpi_ft5406_data *ts_data)
+{
+	u8 td_status;
+	int ret;
+
+	ret = fts_read_reg(ts_data->client, FT_TD_STATUS_REG, &td_status);
+	if (ret < 0) {
+		LOG_ERR("get reg td_status failed, %d\n", ret);
+		return ret;
+	}
+	return td_status;
+}
+
+static int fts_read_touchdata(struct rpi_ft5406_data *ts_data)
+{
+	struct ts_event *event = &ts_data->event;
+	int ret, i;
+	u8 buf[FT_ONE_TCH_LEN-2] = { 0 };
+	u8 reg_addr, pointid = FT_MAX_ID;
+
+	for (i = 0; i < event->touch_point && i < MAX_TOUCH_POINTS; i++) {
+		reg_addr = FT_TOUCH_X_H_REG + (i * FT_ONE_TCH_LEN);
+		ret = fts_i2c_read(ts_data->client, &reg_addr, 1, buf,
+				   FT_ONE_TCH_LEN - 2);
+		if (ret < 0) {
+			LOG_ERR("read touchdata failed.\n");
+			return ret;
+		}
+
+		pointid = (buf[FT_TOUCH_ID]) >> 4;
+		if (pointid >= MAX_TOUCH_POINTS)
+			break;
+		event->au8_finger_id[i] = pointid;
+		event->au16_x[i] = (s16)(buf[FT_TOUCH_X_H] & 0x0F) << 8 |
+			(s16)buf[FT_TOUCH_X_L];
+		event->au16_y[i] = (s16)(buf[FT_TOUCH_Y_H] & 0x0F) << 8 |
+			(s16)buf[FT_TOUCH_Y_L];
+		event->au8_touch_event[i] = buf[FT_TOUCH_EVENT] >> 6;
+
+#if XY_REVERSE
+		event->au16_x[i] = SCREEN_WIDTH - event->au16_x[i] - 1;
+		event->au16_y[i] = SCREEN_HEIGHT - event->au16_y[i] - 1;
+#endif
+	}
+	event->pressure = FT_PRESS;
+
+	return 0;
+}
+
+static void fts_report_value(struct rpi_ft5406_data *ts_data)
+{
+	struct ts_event *event = &ts_data->event;
+	int i, modified_ids = 0, released_ids;
+
+	for (i = 0; i < event->touch_point && i < MAX_TOUCH_POINTS; i++) {
+		if (event->au8_touch_event[i] == FT_TOUCH_DOWN ||
+		    event->au8_touch_event[i] == FT_TOUCH_CONTACT) {
+			modified_ids |= 1 << event->au8_finger_id[i];
+			input_mt_slot(ts_data->input_dev,
+				      event->au8_finger_id[i]);
+			input_mt_report_slot_state(ts_data->input_dev,
+						   MT_TOOL_FINGER,
+						   true);
+			input_report_abs(ts_data->input_dev,
+					 ABS_MT_TOUCH_MAJOR, event->pressure);
+			input_report_abs(ts_data->input_dev, ABS_MT_POSITION_X,
+					 event->au16_x[i]);
+			input_report_abs(ts_data->input_dev, ABS_MT_POSITION_Y,
+					 event->au16_y[i]);
+
+			if (!((1 << event->au8_finger_id[i]) &
+			      ts_data->known_ids))
+				LOG_DBG("Touch id-%d: x = %d, y = %d\n",
+					event->au8_finger_id[i],
+					event->au16_x[i], event->au16_y[i]);
+		}
+	}
+
+	released_ids = ts_data->known_ids & ~modified_ids;
+	for (i = 0; released_ids && i < MAX_TOUCH_POINTS; i++) {
+		if (released_ids & (1 << i)) {
+			LOG_DBG("Release id-%d, known = %x modified = %x\n",
+				i, ts_data->known_ids, modified_ids);
+			input_mt_slot(ts_data->input_dev, i);
+			input_mt_report_slot_state(ts_data->input_dev,
+						   MT_TOOL_FINGER, false);
+			modified_ids &= ~(1 << i);
+		}
+	}
+	ts_data->known_ids = modified_ids;
+	input_mt_report_pointer_emulation(ts_data->input_dev, true);
+	input_sync(ts_data->input_dev);
+}
+
+static void fts_retry_clear(struct rpi_ft5406_data *ts_data)
+{
+	if (ts_data->retry_count != 0)
+		ts_data->retry_count = 0;
+}
+
+static int fts_retry_wait(struct rpi_ft5406_data *ts_data)
+{
+	if (ts_data->retry_count < RETRY_COUNT) {
+		LOG_INFO("wait and retry, count = %d\n", ts_data->retry_count);
+		ts_data->retry_count++;
+		msleep_interruptible(1000);
+		return 1;
+	}
+	LOG_ERR("attach retry count\n");
+	return 0;
+}
+
+static void rpi_ft5406_work(struct work_struct *work)
+{
+	struct ts_event *event = &g_ts_data.event;
+	int ret = 0, count = 5, td_status;
+
+	while (count > 0) {
+		ret = fts_check_fw_ver(g_ts_data.client);
+		if (ret == 0)
+			break;
+		LOG_INFO("checking touch ic, countdown: %d\n", count);
+		msleep_interruptible(1000);
+		count--;
+	}
+	if (!count) {
+		LOG_ERR("checking touch ic timeout, %d\n", ret);
+		g_ts_data.is_polling = 0;
+		return;
+	}
+
+	/* polling 60fps */
+	while (1) {
+		td_status = fts_read_td_status(&g_ts_data);
+		if (td_status < 0) {
+			ret = fts_retry_wait(&g_ts_data);
+			if (ret == 0) {
+				LOG_ERR("stop touch polling\n");
+				g_ts_data.is_polling = 0;
+				break;
+			}
+		} else if (td_status < VALID_TD_STATUS_VAL + 1 &&
+			   (td_status > 0 || g_ts_data.known_ids != 0)) {
+			fts_retry_clear(&g_ts_data);
+			memset(event, -1, sizeof(struct ts_event));
+			event->touch_point = td_status;
+			ret = fts_read_touchdata(&g_ts_data);
+			if (ret == 0)
+				fts_report_value(&g_ts_data);
+		}
+		msleep_interruptible(17);
+	}
+}
+
+void rpi_ft5406_start_polling(void)
+{
+	if (g_ts_data.polling_enabled && g_ts_data.is_polling != 1) {
+		g_ts_data.is_polling = 1;
+		schedule_work(&g_ts_data.ft5406_work);
+	} else {
+		g_ts_data.is_polling = 1;
+	}
+}
+EXPORT_SYMBOL_GPL(rpi_ft5406_start_polling);
+
+static int rpi_ft5406_probe(struct i2c_client *client)
+			    
+{
+	struct input_dev *input_dev;
+	int ret, timeout = 10;
+
+	LOG_INFO("address = 0x%x\n", client->addr);
+
+	g_ts_data.client = client;
+	i2c_set_clientdata(client, &g_ts_data);
+
+	while (!rpi_display_is_connected() && timeout > 0) {
+		msleep(50);
+		timeout--;
+	}
+
+	if (!rpi_display_is_connected()) {
+		LOG_ERR("wait connected timeout\n");
+		ret = -ENODEV;
+		goto timeout_failed;
+	}
+
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		LOG_ERR("failed to allocate input device\n");
+		ret = -ENOMEM;
+		goto input_allocate_failed;
+	}
+	input_dev->name = "fts_ts";
+	input_dev->id.bustype = BUS_I2C;
+	input_dev->dev.parent = &g_ts_data.client->dev;
+
+	g_ts_data.input_dev = input_dev;
+	input_set_drvdata(input_dev, &g_ts_data);
+
+	__set_bit(EV_SYN, input_dev->evbit);
+	__set_bit(EV_KEY, input_dev->evbit);
+	__set_bit(EV_ABS, input_dev->evbit);
+	__set_bit(BTN_TOUCH, input_dev->keybit);
+
+	input_mt_init_slots(input_dev, MAX_TOUCH_POINTS, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0,
+			     SCREEN_WIDTH, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0,
+			     SCREEN_HEIGHT, 0, 0);
+
+	ret = input_register_device(input_dev);
+	if (ret) {
+		LOG_ERR("Input device registration failed\n");
+		goto input_register_failed;
+	}
+
+	INIT_WORK(&g_ts_data.ft5406_work, rpi_ft5406_work);
+	g_ts_data.polling_enabled = 1;
+
+	if (g_ts_data.is_polling)
+		schedule_work(&g_ts_data.ft5406_work);
+
+	return 0;
+
+input_register_failed:
+	input_free_device(input_dev);
+input_allocate_failed:
+timeout_failed:
+	return ret;
+}
+
+static void rpi_ft5406_remove(struct i2c_client *client)
+{
+	struct rpi_ft5406_data *ts_data = i2c_get_clientdata(client);
+
+	cancel_work_sync(&ts_data->ft5406_work);
+	if (ts_data->input_dev) {
+		input_unregister_device(ts_data->input_dev);
+		input_free_device(ts_data->input_dev);
+	}
+//	return 0;
+}
+
+static const struct i2c_device_id rpi_ft5406_id[] = {
+	{ "rpi_ft5406", },
+	{}
+};
+
+static struct i2c_driver rpi_ft5406_driver = {
+	.driver = {
+		.name = "rpi_ft5406",
+	},
+	.probe = rpi_ft5406_probe,
+	.remove = rpi_ft5406_remove,
+	.id_table = rpi_ft5406_id,
+};
+module_i2c_driver(rpi_ft5406_driver);
+
+MODULE_DESCRIPTION("RPI Display FT5406 Touch driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/input/touchscreen/rpi_ft5406.h b/drivers/input/touchscreen/rpi_ft5406.h
new file mode 100644
index 0000000000000..c8c48b319ec47
--- /dev/null
+++ b/drivers/input/touchscreen/rpi_ft5406.h
@@ -0,0 +1,69 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#ifndef _RPI_FT5406_H_
+#define _RPI_FT5406_H_
+
+#define LOG_DBG(fmt, arg...)	pr_debug("rpi-ft5406: %s: "fmt, __func__, ##arg)
+#define LOG_INFO(fmt, arg...)	pr_info("rpi-ft5406: %s: "fmt, __func__, ##arg)
+#define LOG_ERR(fmt, arg...)	pr_err("rpi-ft5406: %s: "fmt, __func__, ##arg)
+
+#define RETRY_COUNT		10
+#define XY_REVERSE		1
+
+#define SCREEN_WIDTH		800
+#define SCREEN_HEIGHT		480
+
+#define FT_ONE_TCH_LEN		6
+
+#define FT_REG_FW_VER		0xA6
+#define FT_REG_FW_MIN_VER	0xB2
+#define FT_REG_FW_SUB_MIN_VER	0xB3
+
+#define VALID_TD_STATUS_VAL	10
+#define MAX_TOUCH_POINTS	1
+
+#define FT_PRESS		0x7F
+#define FT_MAX_ID		0x0F
+
+#define FT_TOUCH_X_H		0
+#define FT_TOUCH_X_L		1
+#define FT_TOUCH_Y_H		2
+#define FT_TOUCH_Y_L		3
+#define FT_TOUCH_EVENT		0
+#define FT_TOUCH_ID		2
+
+#define FT_TOUCH_X_H_REG	3
+#define FT_TOUCH_X_L_REG	4
+#define FT_TOUCH_Y_H_REG	5
+#define FT_TOUCH_Y_L_REG	6
+#define FT_TD_STATUS_REG	2
+#define FT_TOUCH_EVENT_REG	3
+#define FT_TOUCH_ID_REG		5
+
+#define FT_TOUCH_DOWN		0
+#define FT_TOUCH_CONTACT	2
+
+struct ts_event {
+	u16 au16_x[MAX_TOUCH_POINTS]; /* x coordinate */
+	u16 au16_y[MAX_TOUCH_POINTS]; /* y coordinate */
+	u8 au8_touch_event[MAX_TOUCH_POINTS]; /* touch event: 0:down; 1:up; 2:contact */
+	u8 au8_finger_id[MAX_TOUCH_POINTS]; /* touch ID */
+	u16 pressure;
+	u8 touch_point;
+	u8 point_num;
+};
+
+struct rpi_ft5406_data {
+	struct device *dev;
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	struct ts_event event;
+	struct work_struct ft5406_work;
+
+	int is_polling;
+	int polling_enabled;
+	int known_ids;
+	int retry_count;
+};
+
+#endif
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index 358ad56f65245..e42f6cf1c4c5e 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -470,6 +470,14 @@ config HISI_HIKEY_USB
 	  found on HiKey 960/970 boards, which is necessary to support
 	  switching between the dual-role USB-C port and the USB-A host ports
 	  using only one USB controller.
+	  
+config RPI_DISPLAY
+	tristate "RaspberryPi 7inch Display Power Controller"
+	default y
+	depends on I2C
+	help
+	  Attiny88 controlling the power of toshiba tc358762xbg chip
+	  and backlight of RaspberryPi 7inch display.
 
 config OPEN_DICE
 	tristate "Open Profile for DICE driver"
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index ac9b3e757ba1d..f2bdfc0e2b08b 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -62,3 +62,4 @@ obj-$(CONFIG_HI6421V600_IRQ)	+= hi6421v600-irq.o
 obj-$(CONFIG_OPEN_DICE)		+= open-dice.o
 obj-$(CONFIG_GP_PCI1XXXX)	+= mchp_pci1xxxx/
 obj-$(CONFIG_VCPU_STALL_DETECTOR)	+= vcpu_stall_detector.o
+obj-$(CONFIG_RPI_DISPLAY)	+= rpi_display.o
diff --git a/drivers/misc/rpi_display.c b/drivers/misc/rpi_display.c
new file mode 100644
index 0000000000000..c06bf000f3be2
--- /dev/null
+++ b/drivers/misc/rpi_display.c
@@ -0,0 +1,209 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *
+ * Raspberrypi 7inch i2c driver.
+ *
+ * Copyright (C) 2020 Markus Bauer <MB@karo-electronics.de>
+ *
+ * based on: drivers/misc/rpi_display.c
+ * from: https://github.com/TinkerEdgeT/mendel-linux-imx
+ *
+ *     Copyright (c) 2016 ASUSTek Computer Inc.
+ *     Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+ *
+ */
+
+#include <drm/rpi_display.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/workqueue.h>
+#include "rpi_display.h"
+
+static struct rpi_display_data *g_mcu_data;
+static int connected;
+
+static int send_cmds(struct i2c_client *client, const char *buf, size_t size)
+{
+	int ret;
+
+	print_hex_dump_bytes("send_cmds: ", DUMP_PREFIX_OFFSET, buf, size);
+
+	ret = i2c_master_send(client, buf, size);
+	if (ret <= 0) {
+		LOG_ERR("send command failed, ret = %d\n", ret);
+		return ret ?: -ECOMM;
+	}
+	usleep_range(20000, 21000);
+	return ret;
+}
+
+static int recv_cmds(struct i2c_client *client, char *buf, int size)
+{
+	int ret;
+
+	ret = i2c_master_recv(client, buf, size);
+	if (ret <= 0) {
+		LOG_ERR("receive commands failed, %d\n", ret);
+		return ret ?: -ECOMM;
+	}
+	usleep_range(20000, 21000);
+	return ret;
+}
+
+static int init_cmd_check(struct rpi_display_data *mcu_data)
+{
+	int ret;
+	char buf[1] = { 0x80 };
+
+	ret = send_cmds(mcu_data->client, buf, sizeof(buf));
+	if (ret < 0)
+		goto error;
+
+	ret = recv_cmds(mcu_data->client, buf, 1);
+	if (ret < 0)
+		goto error;
+
+	LOG_INFO("recv_cmds: 0x%02X\n", buf[0]);
+	if (buf[0] != 0xC3) {
+		LOG_ERR("received unexpected msg: %02x\n", buf[0]);
+		ret = -EINVAL;
+		goto error;
+
+	}
+	return 0;
+
+error:
+	return ret;
+}
+
+int rpi_display_screen_power_up(void)
+{
+	int ret;
+	char buf[2];
+
+	if (!connected)
+		return -ENODEV;
+
+	LOG_INFO("\n");
+
+	buf[0] = 0x85;
+	buf[1] = 0x00;
+	ret = send_cmds(g_mcu_data->client, buf, sizeof(buf));
+	if (ret <= 0)
+		return ret ?: -ENOMSG;
+	msleep(800);
+
+	buf[1] = 0x01;
+	ret = send_cmds(g_mcu_data->client, buf, sizeof(buf));
+	if (ret <= 0)
+		return ret ?: -ENOMSG;
+	// without sleep next command won't be send
+	usleep_range(20000, 21000);
+
+	buf[0] = 0x81;
+	buf[1] = 0x04;
+	ret = send_cmds(g_mcu_data->client, buf, sizeof(buf));
+	if (ret <= 0)
+		return ret ?: -ENOMSG;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(rpi_display_screen_power_up);
+
+int rpi_display_set_bright(int bright)
+{
+	unsigned char cmd[2];
+	int ret;
+
+	if (!connected)
+		return -ENODEV;
+
+	if (bright > 0xff || bright < 0)
+		return -EINVAL;
+
+	LOG_INFO("bright = 0x%x\n", bright);
+
+	cmd[0] = 0x86;
+	cmd[1] = bright;
+
+	ret = i2c_master_send(g_mcu_data->client, cmd, 2);
+	if (ret <= 0) {
+		LOG_ERR("send command failed, ret = %d\n", ret);
+		return ret ?: -ECOMM;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(rpi_display_set_bright);
+
+int rpi_display_is_connected(void)
+{
+	return connected;
+}
+EXPORT_SYMBOL_GPL(rpi_display_is_connected);
+
+static int rpi_display_probe(struct i2c_client *client)
+
+{
+	struct rpi_display_data *mcu_data;
+	int ret;
+
+	LOG_INFO("address = 0x%02x\n", client->addr);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		LOG_ERR("I2C check functionality failed\n");
+		return -ENODEV;
+	}
+
+	mcu_data = kzalloc(sizeof(struct rpi_display_data), GFP_KERNEL);
+	if (mcu_data == NULL) {
+		LOG_ERR("no memory for device\n");
+		return -ENOMEM;
+	}
+
+	mcu_data->client = client;
+	i2c_set_clientdata(client, mcu_data);
+	g_mcu_data = mcu_data;
+
+	ret = init_cmd_check(mcu_data);
+	if (ret < 0) {
+		LOG_ERR("init_cmd_check failed, %d\n", ret);
+		goto error;
+	}
+	connected = 1;
+
+	return 0;
+
+error:
+	kfree(mcu_data);
+	return ret;
+}
+
+static void rpi_display_remove(struct i2c_client *client)
+{
+	struct rpi_display_data *mcu_data = i2c_get_clientdata(client);
+
+	connected = 0;
+	kfree(mcu_data);
+//	return 0;
+}
+
+static const struct i2c_device_id rpi_display_id[] = {
+	{ "rpi_display", },
+	{ /* sentinel */ }
+};
+
+static struct i2c_driver rpi_display_driver = {
+	.driver = {
+		.name = "rpi_display",
+	},
+	.probe = rpi_display_probe,
+	.remove = rpi_display_remove,
+	.id_table = rpi_display_id,
+};
+module_i2c_driver(rpi_display_driver);
+
+MODULE_DESCRIPTION("Tinker Board TouchScreen MCU driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/misc/rpi_display.h b/drivers/misc/rpi_display.h
new file mode 100644
index 0000000000000..13412cf5bd6c0
--- /dev/null
+++ b/drivers/misc/rpi_display.h
@@ -0,0 +1,16 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#ifndef _RPI_DISPLAY_H_
+#define _RPI_DISPLAY_H_
+
+#define LOG_INFO(fmt, arg...) pr_info("raspi-display: %s: "fmt, __func__, ##arg)
+#define LOG_ERR(fmt, arg...)  pr_err("raspi-display: %s: "fmt, __func__, ##arg)
+
+#define MAX_I2C_LEN 255
+
+struct rpi_display_data {
+	struct device *dev;
+	struct i2c_client *client;
+};
+
+#endif
diff --git a/include/drm/rpi_display.h b/include/drm/rpi_display.h
new file mode 100644
index 0000000000000..107f55d2cbad5
--- /dev/null
+++ b/include/drm/rpi_display.h
@@ -0,0 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+int rpi_display_screen_power_up(void);
+void rpi_ft5406_start_polling(void);
+int rpi_display_set_bright(int bright);
+int rpi_display_is_connected(void);
