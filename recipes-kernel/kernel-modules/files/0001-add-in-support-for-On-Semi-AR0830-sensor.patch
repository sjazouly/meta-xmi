From 8d7f171d6f31ef2382b0bc79113139bcac82ddb2 Mon Sep 17 00:00:00 2001
From: Don Gunn <don.gunn@futureelectronics.com>
Date: Mon, 2 Dec 2024 09:39:34 -0800
Subject: [PATCH] add in support for On Semi AR0830 sensor.

---
 build-all-vvcam.sh                            |    1 +
 vvcam/common/vvsensor.h                       |    8 +-
 vvcam/common/vvsensor.h.bak                   |  273 ++++
 vvcam/dwe/BUILD.bazel                         |    1 +
 vvcam/isp/BUILD.bazel                         |    1 +
 vvcam/readme_v4l2.txt                         |   10 +
 vvcam/v4l2/BUILD.bazel                        |    1 +
 vvcam/v4l2/sensor/Makefile                    |    3 +
 vvcam/v4l2/sensor/ar0830/BUILD.bazel          |   33 +
 vvcam/v4l2/sensor/ar0830/Makefile             |   38 +
 vvcam/v4l2/sensor/ar0830/ar0830_mipi_v3.c     | 1313 +++++++++++++++++
 vvcam/v4l2/sensor/ar0830/ar0830_regs_4k.h     |  730 +++++++++
 .../v4l2/sensor/ar0830/ar0830_regs_4k.h.orig  |  730 +++++++++
 vvcam/version/BUILD.bazel                     |    1 +
 vvcam/vvcam.mk                                |    1 +
 15 files changed, 3142 insertions(+), 2 deletions(-)
 create mode 100644 vvcam/common/vvsensor.h.bak
 create mode 100644 vvcam/v4l2/sensor/ar0830/BUILD.bazel
 create mode 100644 vvcam/v4l2/sensor/ar0830/Makefile
 create mode 100644 vvcam/v4l2/sensor/ar0830/ar0830_mipi_v3.c
 create mode 100644 vvcam/v4l2/sensor/ar0830/ar0830_regs_4k.h
 create mode 100644 vvcam/v4l2/sensor/ar0830/ar0830_regs_4k.h.orig

diff --git a/build-all-vvcam.sh b/build-all-vvcam.sh
index b17b69a..1a6895d 100755
--- a/build-all-vvcam.sh
+++ b/build-all-vvcam.sh
@@ -27,6 +27,7 @@ mkdir -p modules
 cp vvcam/v4l2/dwe/vvcam-dwe.ko modules
 cp vvcam/v4l2/sensor/ov2775/ov2775.ko modules
 cp vvcam/v4l2/sensor/os08a20/os08a20.ko modules
+cp vvcam/v4l2/sensor/ar0830/ar0830.ko modules
 #cp vvcam/v4l2/csi/samsung/vvcam-csis.ko modules
 cp vvcam/v4l2/isp/vvcam-isp.ko modules
 cp vvcam/v4l2/video/vvcam-video.ko modules
diff --git a/vvcam/common/vvsensor.h b/vvcam/common/vvsensor.h
index a1aa20b..3bb53d8 100644
--- a/vvcam/common/vvsensor.h
+++ b/vvcam/common/vvsensor.h
@@ -60,7 +60,7 @@
 #include <linux/uaccess.h>
 #endif
 
-#define VVCAM_SUPPORT_MAX_MODE_COUNT                20
+#define VVCAM_SUPPORT_MAX_MODE_COUNT                6
 #define VVCAM_CAP_BUS_INFO_I2C_ADAPTER_NR_POS       8
 
 #define SENSOR_FIX_FRACBITS 10
@@ -110,7 +110,11 @@ struct vvcam_sccb_data_s {
 	uint32_t addr;
 	uint32_t data;
 };
-
+struct vvcam_sccb_data_with_length_s {
+        uint32_t addr;
+        uint32_t data;
+	uint32_t len;
+};
 /* vsi native usage */
 struct vvcam_sccb_cfg_s {
 	uint8_t slave_addr;
diff --git a/vvcam/common/vvsensor.h.bak b/vvcam/common/vvsensor.h.bak
new file mode 100644
index 0000000..a1aa20b
--- /dev/null
+++ b/vvcam/common/vvsensor.h.bak
@@ -0,0 +1,273 @@
+/****************************************************************************
+ *
+ * The MIT License (MIT)
+ *
+ * Copyright (c) 2020-2021 VeriSilicon Holdings Co., Ltd.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ *****************************************************************************
+ *
+ * The GPL License (GPL)
+ *
+ * Copyright (c) 2020-2021 VeriSilicon Holdings Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program;
+ *
+ *****************************************************************************
+ *
+ * Note: This software is released under dual MIT and GPL licenses. A
+ * recipient may use this file under the terms of either the MIT license or
+ * GPL License. If you wish to use only one license not the other, you can
+ * indicate your decision by deleting one of the above license notices in your
+ * version of this file.
+ *
+ *****************************************************************************/
+
+#ifndef _VVSENSOR_PUBLIC_HEADER_H_
+#define _VVSENSOR_PUBLIC_HEADER_H_
+
+#ifndef __KERNEL__
+#include <stdint.h>
+#else
+#include <linux/uaccess.h>
+#endif
+
+#define VVCAM_SUPPORT_MAX_MODE_COUNT                20
+#define VVCAM_CAP_BUS_INFO_I2C_ADAPTER_NR_POS       8
+
+#define SENSOR_FIX_FRACBITS 10
+
+enum {
+	VVSENSORIOC_RESET = 0x100,
+	VVSENSORIOC_S_POWER,
+	VVSENSORIOC_G_POWER,
+	VVSENSORIOC_S_CLK,
+	VVSENSORIOC_G_CLK,
+	VVSENSORIOC_QUERY,
+	VVSENSORIOC_S_SENSOR_MODE,
+	VVSENSORIOC_G_SENSOR_MODE,
+	VVSENSORIOC_READ_REG,
+	VVSENSORIOC_WRITE_REG,
+	VVSENSORIOC_READ_ARRAY,
+	VVSENSORIOC_WRITE_ARRAY,
+	VVSENSORIOC_G_NAME,
+	VVSENSORIOC_G_RESERVE_ID,
+	VVSENSORIOC_G_CHIP_ID,
+	VVSENSORIOC_S_INIT,
+	VVSENSORIOC_S_STREAM,
+	VVSENSORIOC_S_LONG_EXP,
+	VVSENSORIOC_S_EXP,
+	VVSENSORIOC_S_VSEXP,
+	VVSENSORIOC_S_LONG_GAIN,
+	VVSENSORIOC_S_GAIN,
+	VVSENSORIOC_S_VSGAIN,
+	VVSENSORIOC_S_FPS,
+	VVSENSORIOC_G_FPS,
+	VVSENSORIOC_S_HDR_RADIO,
+	VVSENSORIOC_S_WB,
+	VVSENSORIOC_S_BLC,
+	VVSENSORIOC_G_EXPAND_CURVE,
+	VVSENSORIOC_S_TEST_PATTERN,
+	VVSENSORIOC_G_LENS,
+	VVSENSORIOC_MAX,
+};
+
+struct vvcam_clk_s {
+	uint32_t      status;
+	unsigned long sensor_mclk;
+	unsigned long csi_max_pixel_clk;
+};
+/* W/R registers */
+struct vvcam_sccb_data_s {
+	uint32_t addr;
+	uint32_t data;
+};
+
+/* vsi native usage */
+struct vvcam_sccb_cfg_s {
+	uint8_t slave_addr;
+	uint8_t addr_byte;
+	uint8_t data_byte;
+};
+
+struct vvcam_sccb_array_s {
+	uint32_t count;
+	struct vvcam_sccb_data_s *sccb_data;
+};
+
+typedef struct sensor_hdr_artio_s {
+	uint32_t ratio_l_s;
+	uint32_t ratio_s_vs;
+	uint32_t accuracy;
+} sensor_hdr_artio_t;
+
+typedef struct vvcam_ae_info_s {
+	uint32_t def_frm_len_lines;
+	uint32_t curr_frm_len_lines;
+	uint32_t one_line_exp_time_ns;
+	/*
+	 * normal use  max_integration_line
+	 * 2Expsoure use max_integration_line and max_vsintegration_line
+	 *
+	 */
+	uint32_t max_longintegration_line;
+	uint32_t min_longintegration_line;
+
+	uint32_t max_integration_line;
+	uint32_t min_integration_line;
+
+	uint32_t max_vsintegration_line;
+	uint32_t min_vsintegration_line;
+
+	uint32_t max_long_again;
+	uint32_t min_long_again;
+	uint32_t max_long_dgain;
+	uint32_t min_long_dgain;
+
+	uint32_t max_again;
+	uint32_t min_again;
+	uint32_t max_dgain;
+	uint32_t min_dgain;
+
+	uint32_t max_short_again;
+	uint32_t min_short_again;
+	uint32_t max_short_dgain;
+	uint32_t min_short_dgain;
+
+	uint32_t start_exposure;
+
+	uint32_t gain_step;
+	uint32_t cur_fps;
+	uint32_t max_fps;
+	uint32_t min_fps;
+	uint32_t min_afps;
+	uint8_t  int_update_delay_frm;
+	uint8_t  gain_update_delay_frm;
+	struct sensor_hdr_artio_s hdr_ratio;
+} vvcam_ae_info_t;
+
+struct sensor_mipi_info_s {
+	uint32_t mipi_lane;
+};
+
+enum sensor_hdr_mode_e {
+	SENSOR_MODE_LINEAR,
+	SENSOR_MODE_HDR_STITCH,
+	SENSOR_MODE_HDR_NATIVE,
+};
+
+enum sensor_bayer_pattern_e {
+	BAYER_RGGB = 0,
+	BAYER_GRBG = 1,
+	BAYER_GBRG = 2,
+	BAYER_BGGR = 3,
+	BAYER_BUTT
+};
+
+enum sensor_stitching_mode_e {
+	SENSOR_STITCHING_DUAL_DCG           = 0,    /**< dual DCG mode 3x12-bit */
+	SENSOR_STITCHING_3DOL               = 1,    /**< dol3 frame 3x12-bit */
+	SENSOR_STITCHING_LINEBYLINE         = 2,    /**< 3x12-bit line by line without waiting */
+	SENSOR_STITCHING_16BIT_COMPRESS     = 3,    /**< 16-bit compressed data + 12-bit RAW */
+	SENSOR_STITCHING_DUAL_DCG_NOWAIT    = 4,    /**< 2x12-bit dual DCG without waiting */
+	SENSOR_STITCHING_2DOL               = 5,    /**< dol2 frame or 1 CG+VS sx12-bit RAW */
+	SENSOR_STITCHING_L_AND_S            = 6,    /**< L+S 2x12-bit RAW */
+	SENSOR_STITCHING_MAX
+
+};
+
+typedef struct sensor_test_pattern_s {
+	uint8_t enable;
+	uint32_t pattern;
+}sensor_test_pattern_t;
+
+typedef struct sensor_expand_curve_s {
+	uint32_t x_bit;
+	uint32_t y_bit;
+	uint8_t expand_px[64];
+	uint32_t expand_x_data[65];
+	uint32_t expand_y_data[65];
+} sensor_expand_curve_t;
+
+typedef struct sensor_data_compress_s {
+	uint32_t enable;
+	uint32_t x_bit;
+	uint32_t y_bit;
+} sensor_data_compress_t;
+
+typedef struct vvcam_size_s {
+	uint32_t bounds_width;
+	uint32_t bounds_height;
+	uint32_t top;
+	uint32_t left;
+	uint32_t width;
+	uint32_t height;
+} vvcam_size_t;
+
+typedef struct vvcam_mode_info_s {
+	uint32_t index;
+	vvcam_size_t size;
+	uint32_t hdr_mode;
+	uint32_t stitching_mode;
+	uint32_t bit_width;
+	sensor_data_compress_t data_compress;
+	uint32_t bayer_pattern;
+	vvcam_ae_info_t ae_info;
+	struct sensor_mipi_info_s mipi_info;
+	void *preg_data;
+	uint32_t reg_data_count;
+} vvcam_mode_info_t;
+
+typedef struct sensor_blc_s {
+	uint32_t red;
+	uint32_t gr;
+	uint32_t gb;
+	uint32_t blue;
+} sensor_blc_t;
+
+typedef struct sensor_white_balance_s {
+	uint32_t r_gain;
+	uint32_t gr_gain;
+	uint32_t gb_gain;
+	uint32_t b_gain;
+} sensor_white_balance_t;
+
+typedef struct vvcam_mode_info_array_s {
+	uint32_t count;
+	struct vvcam_mode_info_s modes[VVCAM_SUPPORT_MAX_MODE_COUNT];
+} vvcam_mode_info_array_t;
+
+typedef struct vvcam_lens_s {
+	uint32_t id;
+	char name[16];
+} vvcam_lens_t;
+
+#endif
diff --git a/vvcam/dwe/BUILD.bazel b/vvcam/dwe/BUILD.bazel
index 861829c..99a97a4 100644
--- a/vvcam/dwe/BUILD.bazel
+++ b/vvcam/dwe/BUILD.bazel
@@ -11,5 +11,6 @@ filegroup(
         "//verisilicon_sw_isp_vvcam/vvcam/v4l2/dwe:__subpackages__",
         "//verisilicon_sw_isp_vvcam/vvcam/v4l2/isp:__subpackages__",
         "//verisilicon_sw_isp_vvcam/vvcam/v4l2/sensor/os08a20:__subpackages__",
+        "//verisilicon_sw_isp_vvcam/vvcam/v4l2/sensor/ar0830:__subpackages__",
     ],
 )
diff --git a/vvcam/isp/BUILD.bazel b/vvcam/isp/BUILD.bazel
index 743f394..a5087d4 100644
--- a/vvcam/isp/BUILD.bazel
+++ b/vvcam/isp/BUILD.bazel
@@ -11,5 +11,6 @@ filegroup(
         "//verisilicon_sw_isp_vvcam/vvcam/v4l2/dwe:__subpackages__",
         "//verisilicon_sw_isp_vvcam/vvcam/v4l2/isp:__subpackages__",
         "//verisilicon_sw_isp_vvcam/vvcam/v4l2/sensor/os08a20:__subpackages__",
+        "//verisilicon_sw_isp_vvcam/vvcam/v4l2/sensor/ar0830:__subpackages__",
     ],
 )
diff --git a/vvcam/readme_v4l2.txt b/vvcam/readme_v4l2.txt
index a356b46..2147580 100644
--- a/vvcam/readme_v4l2.txt
+++ b/vvcam/readme_v4l2.txt
@@ -9,6 +9,7 @@ find -name *.ko
 ./v4l2/vvcam-dwe.ko
 ./v4l2/sensor/ov2775/ov2775.ko
 ./v4l2/sensor/os08a20/os08a20.ko
+./v4l2/sensor/ar0830/ar0830.ko
 ./v4l2/csi/samsung/vvcam-csis.ko
 ./v4l2/video/vvcam-video.ko
 ./v4l2/vvcam-isp.ko
@@ -47,3 +48,12 @@ insmod vvcam-dwe.ko
 insmod vvcam-isp.ko
 insmod vvcam-video.ko
 insmod imx8-media-dev.ko
+
+
+ar0830 insmod:
+cp $Kernel_SRC/driver/staging/media/imx/imx8-media-dev.ko to your board directory
+insmod ar0830.ko
+insmod vvcam-dwe.ko
+insmod vvcam-isp.ko
+insmod vvcam-video.ko
+insmod imx8-media-dev.ko
diff --git a/vvcam/v4l2/BUILD.bazel b/vvcam/v4l2/BUILD.bazel
index 97b9337..3d03825 100644
--- a/vvcam/v4l2/BUILD.bazel
+++ b/vvcam/v4l2/BUILD.bazel
@@ -27,6 +27,7 @@ kernel_module(
          "vvcam-isp.ko",
          "vvcam-dwe.ko",
          "sensor/os08a20/os08a20.ko",
+         "sensor/ar0830/ar0830.ko",
          "sensor/ar1335/ar1335.ko",
          "video/vvcam-video.ko",
          "focus/vcm_dw9790/vcm-dw9790.ko",
diff --git a/vvcam/v4l2/sensor/Makefile b/vvcam/v4l2/sensor/Makefile
index 92f515f..c7989e6 100644
--- a/vvcam/v4l2/sensor/Makefile
+++ b/vvcam/v4l2/sensor/Makefile
@@ -2,17 +2,20 @@ all:
 	@cd ov2775;  make || exit $$?;
 	@cd os08a20; make || exit $$?;
 	@cd ar1335;  make || exit $$?;
+	@cd ar0830;  make || exit $$?;
 	@cd camera-proxy-driver;  make || exit $$?;
 
 clean:
 	@cd ov2775;   make clean;
 	@cd os08a20;  make clean;
 	@cd ar1335;   make clean;
+	@cd ar0830;   make clean;
 	@cd camera-proxy-driver;   make clean;
 
 modules_install:
 	@cd ov2775;   make modules_install;
 	@cd os08a20;  make modules_install;
 	@cd ar1335;   make modules_install;
+	@cd ar0830;   make modules_install;
 	@cd camera-proxy-driver;   make modules_install;
 
diff --git a/vvcam/v4l2/sensor/ar0830/BUILD.bazel b/vvcam/v4l2/sensor/ar0830/BUILD.bazel
new file mode 100644
index 0000000..ebce81f
--- /dev/null
+++ b/vvcam/v4l2/sensor/ar0830/BUILD.bazel
@@ -0,0 +1,33 @@
+# NOTE: THIS FILE IS EXPERIMENTAL FOR THE BAZEL MIGRATION AND NOT USED FOR
+# YOUR BUILDS CURRENTLY.
+#
+# It is not yet the source of truth for your build. If you're looking to modify
+# the build file, modify the Android.bp file instead. Do *not* modify this file
+# unless you have coordinated with the team managing the Soong to Bazel
+# migration.
+
+load("//build/kernel/kleaf:kernel.bzl", "kernel_module")
+
+kernel_module(
+    name = "isp.imx.ar0830",
+    srcs = glob([
+        "**"
+        ],
+        exclude = [
+            "**/.*",          # Hidden files
+            "**/.*/**",       # Files in hidden directories
+            "**/BUILD.bazel", # build files
+            "**/*.bzl",       # build files
+        ],) + [
+            "//verisilicon_sw_isp_vvcam/vvcam/isp:isp_sources",
+            "//verisilicon_sw_isp_vvcam/vvcam/version:version_sources",
+            "//verisilicon_sw_isp_vvcam/vvcam/dwe:dwe_sources",
+        ],
+    outs = [
+         "ar0830.ko",
+    ],
+    kernel_build = "//common:imx",
+    visibility = [
+        "//common:__pkg__",
+    ],
+)
diff --git a/vvcam/v4l2/sensor/ar0830/Makefile b/vvcam/v4l2/sensor/ar0830/Makefile
new file mode 100644
index 0000000..b701f54
--- /dev/null
+++ b/vvcam/v4l2/sensor/ar0830/Makefile
@@ -0,0 +1,38 @@
+PWD := $(shell dirname $(realpath $(lastword $(MAKEFILE_LIST))))
+
+TARGET = ar0830
+
+obj-m +=$(TARGET).o
+$(TARGET)-objs += ar0830_mipi_v3.o
+
+ccflags-y += -I$(PWD)/../../../common/
+ccflags-y += -O2 -Werror -Wmissing-declarations -Wmissing-prototypes
+
+ARCH_TYPE ?= arm64
+ANDROID ?= no
+
+ifeq ($(ANDROID), yes)
+
+V := 1
+
+all:
+	@$(MAKE) V=$(V) -C $(KERNEL_SRC) ARCH=$(ARCH_TYPE) M=$(PWD) modules
+modules_install:
+	@$(MAKE) V=$(V) -C $(KERNEL_SRC) M=$(PWD) modules_install
+clean:
+	@rm -rf modules.order Module.symvers
+	@find ../ -name "*.o" | xargs rm -f
+	@find ../ -name "*.ko" | xargs rm -f
+
+else
+
+all:
+	make -C $(KERNEL_SRC) ARCH=$(ARCH_TYPE) M=$(PWD) modules
+modules_install:
+	make -C $(KERNEL_SRC) M=$(PWD) modules_install
+clean:
+	rm -rf $($(TARGET)-objs)
+	make -C $(KERNEL_SRC) M=$(PWD) clean
+
+endif
+
diff --git a/vvcam/v4l2/sensor/ar0830/ar0830_mipi_v3.c b/vvcam/v4l2/sensor/ar0830/ar0830_mipi_v3.c
new file mode 100644
index 0000000..cf8d498
--- /dev/null
+++ b/vvcam/v4l2/sensor/ar0830/ar0830_mipi_v3.c
@@ -0,0 +1,1313 @@
+/*
+* Copyright (C) 2012-2015 Freescale Semiconductor, Inc. All Rights Reserved.
+* Copyright 2018 NXP
+* Copyright (c) 2020 VeriSilicon Holdings Co., Ltd.
+* Copyright 2022 Semiconductor Components Industries, LLC ("onsemi").
+*/
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/of_graph.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/regulator/consumer.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-fwnode.h>
+#include <linux/uaccess.h>
+#include <linux/version.h>
+#include "vvsensor.h"
+#include "ar0830_regs_4k.h"
+
+
+#define AR0830_VOLTAGE_ANALOG			2800000
+#define AR0830_VOLTAGE_DIGITAL_CORE		1500000
+#define AR0830_VOLTAGE_DIGITAL_IO		1800000
+
+#define AR0830_XCLK_MIN 6000000
+#define AR0830_XCLK_MAX 48000000
+
+#define AR0830_CHIP_ID                  0x553
+#define AR0830_CHIP_VERSION_REG 		0x0016
+#define AR0830_RESET_REG                0x0103
+
+#define AR0830_SENS_PAD_SOURCE	0
+#define AR0830_SENS_PADS_NUM	1
+
+#define AR0830_RESERVE_ID 0X2770
+#define DCG_CONVERSION_GAIN 11
+
+#define AR0830_REG_CTRL_MODE		0x0100
+#define AR0830_MODE_SW_STANDBY	0x00
+#define AR0830_MODE_STREAMING		0x01
+
+#define AR0830_GAIN_MIN		0x00
+#define AR0830_GAIN_MAX		127
+#define AR0830_REG_GAIN		0x3062
+#define AR0830_REG_GAIN2	0x3062
+
+#define client_to_ar0830(client)\
+	container_of(i2c_get_clientdata(client), struct ar0830, subdev)
+
+struct ar0830_capture_properties {
+	__u64 max_lane_frequency;
+	__u64 max_pixel_frequency;
+	__u64 max_data_rate;
+};
+
+struct ar0830 {
+	struct i2c_client *i2c_client;
+	struct regulator *io_regulator;
+	struct regulator *core_regulator;
+	struct regulator *analog_regulator;
+	unsigned int pwn_gpio;
+	unsigned int rst_gpio;
+	unsigned int mclk;
+	unsigned int mclk_source;
+	struct clk *sensor_clk;
+	unsigned int csi_id;
+	struct ar0830_capture_properties ocp;
+
+	struct v4l2_subdev subdev;
+	struct media_pad pads[AR0830_SENS_PADS_NUM];
+
+	struct v4l2_mbus_framefmt format;
+	vvcam_mode_info_t cur_mode;
+	sensor_blc_t blc;
+	sensor_white_balance_t wb;
+	struct mutex lock;
+	u32 stream_status;
+	u32 resume_status;
+	vvcam_lens_t focus_lens;
+};
+struct gain_table{
+	unsigned int code;
+	unsigned int times;
+};
+unsigned int GAIN_TABLE_SIZE = 128;
+struct gain_table ar0830_gain_table[] = {
+{0	,1024     },
+{1	,1069     },
+{2	,1116     },
+{3	,1166     },
+{4	,1217     },
+{5	,1271     },
+{6	,1327     },
+{7	,1385     },
+{8	,1441     },
+{9	,1505     },
+{10	,1571     },
+{11	,1641     },
+{12	,1713     },
+{13	,1789     },
+{14	,1868     },
+{15	,1950     },
+{16	,2038     },
+{17	,2127     },
+{18	,2221     },
+{19	,2319     },
+{20	,2422     },
+{21	,2529     },
+{22	,2640     },
+{23	,2757     },
+{24	,2880     },
+{25	,3007     },
+{26	,3140     },
+{27	,3278     },
+{28	,3423     },
+{29	,3574     },
+{30	,3732     },
+{31	,3896     },
+{32	,4064     },
+{33	,4243     },
+{34	,4430     },
+{35	,4626     },
+{36	,4830     },
+{37	,5043     },
+{38	,5265     },
+{39	,5498     },
+{40	,5758     },
+{41	,6012     },
+{42	,6277     },
+{43	,6554     },
+{44	,6843     },
+{45	,7145     },
+{46	,7460     },
+{47	,7789     },
+{48	,8109     },
+{49	,8467     },
+{50	,8840     },
+{51	,9230     },
+{52	,9638     },
+{53	,10063    },
+{54	,10507    },
+{55	,10970    },
+{56	,11472    },
+{57	,11978    },
+{58	,12507    },
+{59	,13059    },
+{60	,13635    },
+{61	,14236    },
+{62	,14864    },
+{63	,15520    },
+{64	,16182    },
+{65	,16896    },
+{66	,17642    },
+{67	,18420    },
+{68	,19233    },
+{69	,20081    },
+{70	,20967    },
+{71	,21892    },
+{72	,22861    },
+{73	,23870    },
+{74	,24923    },
+{75	,26022    },
+{76	,27170    },
+{77	,28369    },
+{78	,29621    },
+{79	,30927    },
+{80	,32357    },
+{81	,33785    },
+{82	,35275    },
+{83	,36831    },
+{84	,38456    },
+{85	,40153    },
+{86	,41925    },
+{87	,43774    },
+{88	,45722    },
+{89	,47739    },
+{90	,49845    },
+{91	,52044    },
+{92	,54341    },
+{93	,56738    },
+{94	,59241    },
+{95	,61855    },
+{96	,64538    },
+{97	,67386    },
+{98	,70359    },
+{99	,73463    },
+{100,	76704 },
+{101,	80088 },
+{102,	83621 },
+{103,	87311 },
+{104,	91180 },
+{105,	95203 },
+{106,	99403 },
+{107,	103789},
+{108,	108368},
+{109,	113149},
+{110,	118141},
+{111,	123353},
+{112,	128901},
+{113,	134588},
+{114,	140525},
+{115,	146725},
+{116,	153199},
+{117,	159958},
+{118,	167015},
+{119,	174383},
+{120,	182008},
+{121,	190038},
+{122,	198423},
+{123,	207177},
+{124,	216317},
+{125,	225861},
+{126,	235826},
+{127,	246230},
+};
+
+static struct vvcam_mode_info_s par0830_mode_info[] = {
+	{
+		.index          = 0,
+		.size           = {
+			.bounds_width  = 3840,
+			.bounds_height = 2160,
+			.top           = 0,
+			.left          = 0,
+			.width         = 3840,
+			.height        = 2160,
+		},
+		.hdr_mode       = SENSOR_MODE_LINEAR,
+		.bit_width      = 10,
+		.data_compress  = {
+			.enable = 0,
+		},
+		.bayer_pattern = BAYER_GRBG,
+		.ae_info = {
+			.def_frm_len_lines     = 0x8A8,
+			.curr_frm_len_lines    = 0x8A8 - 1,
+			.one_line_exp_time_ns  = 15069,
+
+			.max_integration_line  = 0x8A8 - 1,
+			.min_integration_line  = 8,
+
+			.max_again             = 240.45 * (1 << SENSOR_FIX_FRACBITS),//gain times
+			.min_again             = 1 * (1 << SENSOR_FIX_FRACBITS),
+			.max_dgain             = 1 * (1 << SENSOR_FIX_FRACBITS),
+			.min_dgain             = 1 * (1 << SENSOR_FIX_FRACBITS),
+			.gain_step             = 1,
+
+			.start_exposure        = 3 * 100 * (1 << SENSOR_FIX_FRACBITS),
+			.cur_fps               = 30 * (1 << SENSOR_FIX_FRACBITS),
+			.max_fps               = 30 * (1 << SENSOR_FIX_FRACBITS),
+			.min_fps               = 5 * (1 << SENSOR_FIX_FRACBITS),
+			.min_afps              = 5 * (1 << SENSOR_FIX_FRACBITS),
+			.int_update_delay_frm  = 1,
+			.gain_update_delay_frm = 1,
+		},
+		.mipi_info = {
+			.mipi_lane = 4,
+		},
+		.preg_data      = ar0830_init_setting_linear_4k,
+		.reg_data_count = ARRAY_SIZE(ar0830_init_setting_linear_4k),
+	},
+
+};
+
+static int ar0830_get_clk(struct ar0830 *sensor, void *clk)
+{
+	struct vvcam_clk_s vvcam_clk;
+	int ret = 0;
+	vvcam_clk.sensor_mclk = clk_get_rate(sensor->sensor_clk);
+	vvcam_clk.csi_max_pixel_clk = sensor->ocp.max_pixel_frequency;
+	ret = copy_to_user(clk, &vvcam_clk, sizeof(struct vvcam_clk_s));
+	if (ret != 0)
+		ret = -EINVAL;
+	return ret;
+}
+
+static int ar0830_power_on(struct ar0830 *sensor)
+{
+	int ret;
+	pr_debug("enter %s\n", __func__);
+
+	if (gpio_is_valid(sensor->pwn_gpio))
+		gpio_set_value_cansleep(sensor->pwn_gpio, 1);
+
+	ret = clk_prepare_enable(sensor->sensor_clk);
+	if (ret < 0)
+		pr_err("%s: enable sensor clk fail\n", __func__);
+
+	return ret;
+}
+
+static int ar0830_power_off(struct ar0830 *sensor)
+{
+	pr_debug("enter %s\n", __func__);
+	if (gpio_is_valid(sensor->pwn_gpio))
+		gpio_set_value_cansleep(sensor->pwn_gpio, 0);
+	clk_disable_unprepare(sensor->sensor_clk);
+
+	return 0;
+}
+
+static int ar0830_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ar0830 *sensor = client_to_ar0830(client);
+
+	pr_debug("enter %s\n", __func__);
+	if (on)
+		ar0830_power_on(sensor);
+	else
+		ar0830_power_off(sensor);
+
+	return 0;
+}
+//default 16bits data write by i2c
+static s32 ar0830_write_reg(struct ar0830 *sensor, u16 reg, u16 val)
+{
+	struct device *dev = &sensor->i2c_client->dev;
+	u8 au8Buf[4] = { reg >> 8, reg & 0xff, val >> 8, val & 0xff };
+
+	if (i2c_master_send(sensor->i2c_client, au8Buf, 4) < 0) {
+		dev_err(dev, "Write reg error: reg=%x, val=%x\n", reg, val);
+		return -1;
+	}
+	return 0;
+}
+
+static s32 ar0830_write_reg_special(struct ar0830 *sensor, u16 reg, u16 val, u16 bytes)
+{
+	struct device *dev = &sensor->i2c_client->dev;
+	u8 au8Buf[4] = { reg >> 8, reg & 0xff, val >> 8, val & 0xff };;
+
+	if(bytes == 1){
+		au8Buf[2] = val & 0xff;
+	}
+	
+	if (i2c_master_send(sensor->i2c_client, au8Buf, (2+bytes)) < 0) {
+		dev_err(dev, "Write reg special error: reg=%x, val=%x\n", reg, val);
+		return -1;
+	}
+	return 0;
+}
+
+
+static s32 ar0830_read_reg(struct ar0830 *sensor, u16 reg, u16 *val)
+{
+	struct device *dev = &sensor->i2c_client->dev;
+	u8 au8RegBuf[2] = { reg >> 8, reg & 0xff };
+	u8 au8RdVal[2] = {0};
+
+	if (i2c_master_send(sensor->i2c_client, au8RegBuf, 2) != 2) {
+		dev_err(dev, "Read reg error: reg=%x\n", reg);
+		return -1;
+	}
+
+	if (i2c_master_recv(sensor->i2c_client, au8RdVal, 2) != 2) {
+		dev_err(dev, "Read reg error: reg=%x, val=%x %x\n",
+                        reg, au8RdVal[0], au8RdVal[1]);
+		return -1;
+	}
+
+	*val = ((u16)au8RdVal[0] << 8) | (u16)au8RdVal[1];
+
+	return 0;
+}
+
+
+static int ar0830_stream_on(struct ar0830 *sensor)
+{
+	int ret;
+	//u16 val = AR0830_MODE_STREAMING;
+	
+	ret = ar0830_write_reg_special(sensor, AR0830_REG_CTRL_MODE, AR0830_MODE_STREAMING, AR0830_REG_VALUE_08BIT);
+
+	return ret;
+}
+
+static int ar0830_stream_off(struct ar0830 *sensor)
+{
+	int ret;
+	//u16 val = 0;
+
+	ret = ar0830_write_reg_special(sensor, AR0830_REG_CTRL_MODE, AR0830_MODE_SW_STANDBY, AR0830_REG_VALUE_08BIT);
+
+	return ret;
+}
+
+static int ar0830_write_reg_arry(struct ar0830 *sensor,
+				    struct vvcam_sccb_data_with_length_s *mode_setting,
+				    s32 size)
+{
+	register u16 reg_addr = 0;
+	register u16 data = 0;
+	register u16 bytes = 0;
+	int i, retval = 0;
+
+	for (i = 0; i < size; ++i, ++mode_setting) {
+		if (unlikely(mode_setting->addr == REG_DELAY)) {
+			usleep_range(mode_setting->data, mode_setting->data * 2);
+		} else {
+			reg_addr = mode_setting->addr;
+			data = mode_setting->data;
+			bytes = mode_setting->len;
+
+			retval = ar0830_write_reg_special(sensor, reg_addr, data, bytes);
+			if (retval < 0)
+				break;
+		}
+	}
+
+	ar0830_stream_off(sensor);
+
+	return retval;
+}
+
+static int ar0830_query_capability(struct ar0830 *sensor, void *arg)
+{
+	struct v4l2_capability *pcap = (struct v4l2_capability *)arg;
+
+	strcpy((char *)pcap->driver, "ar0830");
+	sprintf((char *)pcap->bus_info, "csi%d",sensor->csi_id);
+	if(sensor->i2c_client->adapter) {
+		pcap->bus_info[VVCAM_CAP_BUS_INFO_I2C_ADAPTER_NR_POS] =
+			(__u8)sensor->i2c_client->adapter->nr;
+	} else {
+		pcap->bus_info[VVCAM_CAP_BUS_INFO_I2C_ADAPTER_NR_POS] = 0xFF;
+	}
+	return 0;
+}
+
+static int ar0830_query_supports(struct ar0830 *sensor, void* parry)
+{
+	int ret = 0;
+	struct vvcam_mode_info_array_s *psensor_mode_arry = parry;
+	uint32_t support_counts = ARRAY_SIZE(par0830_mode_info);
+
+	ret = copy_to_user(&psensor_mode_arry->count, &support_counts, sizeof(support_counts));
+	ret |= copy_to_user(&psensor_mode_arry->modes, par0830_mode_info,
+			   sizeof(par0830_mode_info));
+	if (ret != 0)
+		ret = -ENOMEM;
+	return ret;
+}
+
+static int ar0830_get_sensor_id(struct ar0830 *sensor, void* pchip_id)
+{
+	int ret = 0;
+	u16 chip_id;
+
+	ret = ar0830_read_reg(sensor, 0x3000, &chip_id);
+	ret = copy_to_user(pchip_id, &chip_id, sizeof(u16));
+	if (ret != 0)
+		ret = -ENOMEM;
+	return ret;
+}
+
+static int ar0830_get_reserve_id(struct ar0830 *sensor, void* preserve_id)
+{
+	int ret = 0;
+	u16 reserve_id = 0x2770;
+	ret = copy_to_user(preserve_id, &reserve_id, sizeof(u16));
+	if (ret != 0)
+		ret = -ENOMEM;
+	return ret;
+}
+
+static int ar0830_get_sensor_mode(struct ar0830 *sensor, void* pmode)
+{
+	int ret = 0;
+	ret = copy_to_user(pmode, &sensor->cur_mode,
+		sizeof(struct vvcam_mode_info_s));
+	if (ret != 0)
+		ret = -ENOMEM;
+	return ret;
+}
+
+static int ar0830_set_sensor_mode(struct ar0830 *sensor, void* pmode)
+{
+	int ret = 0;
+	int i = 0;
+	struct vvcam_mode_info_s sensor_mode;
+
+	ret = copy_from_user(&sensor_mode, pmode,
+		sizeof(struct vvcam_mode_info_s));
+	if (ret != 0)
+		return -ENOMEM;
+	for (i = 0; i < ARRAY_SIZE(par0830_mode_info); i++) 
+    {
+		if (par0830_mode_info[i].index == sensor_mode.index) 
+        {
+			memcpy(&sensor->cur_mode, &par0830_mode_info[i],sizeof(struct vvcam_mode_info_s));
+			return 0;
+		}
+	}
+	return -ENXIO;
+}
+
+static int ar0830_set_exp(struct ar0830 *sensor, u32 exp)
+{
+	int ret = 0;
+	ret |= ar0830_write_reg(sensor, 0x0202, exp);
+
+	return ret;
+}
+
+static int ar0830_set_gain(struct ar0830 *sensor, u32 gain)
+{
+	int ret = 0;
+	u16 new_gain = 0;
+	unsigned int i = 0;
+
+	pr_info("%s : %d\n", __func__, gain);
+
+	for(i = 0; i < GAIN_TABLE_SIZE; i++){
+		if(gain <= ar0830_gain_table[i].times){
+			new_gain = ar0830_gain_table[i].code;
+			break;
+		}
+	}
+	if (i == GAIN_TABLE_SIZE){
+		new_gain = AR0830_GAIN_MAX;
+	}
+	if (new_gain > AR0830_GAIN_MAX) {
+		new_gain = AR0830_GAIN_MAX;
+	}else if (new_gain < AR0830_GAIN_MIN) {
+                new_gain = AR0830_GAIN_MIN;
+        }
+
+	ret = ar0830_write_reg(sensor, AR0830_REG_GAIN, new_gain);
+    return ret;
+}
+
+static int ar0830_set_fps(struct ar0830 *sensor, u32 fps)
+{
+	u32 vts;
+	int ret = 0;
+
+	if (fps > sensor->cur_mode.ae_info.max_fps) {
+		fps = sensor->cur_mode.ae_info.max_fps;
+	}
+	else if (fps < sensor->cur_mode.ae_info.min_fps) {
+		fps = sensor->cur_mode.ae_info.min_fps;
+	}
+	vts = sensor->cur_mode.ae_info.max_fps *
+	      sensor->cur_mode.ae_info.def_frm_len_lines / fps;
+
+	ret |= ar0830_write_reg(sensor, 0x0340, vts);
+	sensor->cur_mode.ae_info.cur_fps = fps;
+
+	if (sensor->cur_mode.hdr_mode == SENSOR_MODE_LINEAR) {
+		sensor->cur_mode.ae_info.max_integration_line = vts - 1;
+	} else {
+		if (sensor->cur_mode.stitching_mode ==
+		    SENSOR_STITCHING_DUAL_DCG){
+			sensor->cur_mode.ae_info.max_vsintegration_line = 44;
+			sensor->cur_mode.ae_info.max_integration_line = vts -
+				4 - sensor->cur_mode.ae_info.max_vsintegration_line;
+		} else {
+			sensor->cur_mode.ae_info.max_integration_line = vts - 1;
+		}
+	}
+	sensor->cur_mode.ae_info.curr_frm_len_lines = vts;
+	return ret;
+}
+
+static int ar0830_get_fps(struct ar0830 *sensor, u32 *pfps)
+{
+	*pfps = sensor->cur_mode.ae_info.cur_fps;
+	return 0;
+
+}
+
+static int ar0830_set_test_pattern(struct ar0830 *sensor, void * arg)
+{
+
+	int ret;
+	struct sensor_test_pattern_s test_pattern;
+
+	ret = copy_from_user(&test_pattern, arg, sizeof(test_pattern));
+	if (ret != 0)
+		return -ENOMEM;
+	if (test_pattern.enable) {
+		switch (test_pattern.pattern) {
+		case 0:
+			ret |= ar0830_write_reg(sensor, 0x0600, 0x0001);
+			break;
+		case 1:
+			ret |= ar0830_write_reg(sensor, 0x0600, 0x0002);
+			break;
+		case 2:
+			ret |= ar0830_write_reg(sensor, 0x0600, 0x0003);
+			break;
+		default:
+			ret = -1;
+			break;
+		}
+	}
+	return ret;
+}
+
+static int ar0830_get_lens(struct ar0830 *sensor, void * arg) {
+
+	vvcam_lens_t *pfocus_lens = (vvcam_lens_t *)arg;
+
+	if (!arg)
+		return -ENOMEM;
+
+	if (strlen(sensor->focus_lens.name) == 0)
+		return -1;
+
+	return copy_to_user(pfocus_lens, &sensor->focus_lens, sizeof(vvcam_lens_t));
+}
+
+static int ar0830_get_format_code(struct ar0830 *sensor, u32 *code)
+{
+	switch (sensor->cur_mode.bayer_pattern) {
+	case BAYER_RGGB:
+		if (sensor->cur_mode.bit_width == 8) {
+			*code = MEDIA_BUS_FMT_SRGGB8_1X8;
+		} else if (sensor->cur_mode.bit_width == 10) {
+			*code = MEDIA_BUS_FMT_SRGGB10_1X10;
+		} else {
+			*code = MEDIA_BUS_FMT_SRGGB12_1X12;
+		}
+		break;
+	case BAYER_GRBG:
+		if (sensor->cur_mode.bit_width == 8) {
+			*code = MEDIA_BUS_FMT_SGRBG8_1X8;
+		} else if (sensor->cur_mode.bit_width == 10) {
+			*code = MEDIA_BUS_FMT_SGRBG10_1X10;
+		} else {
+			*code = MEDIA_BUS_FMT_SGRBG12_1X12;
+		}
+		break;
+	case BAYER_GBRG:
+		if (sensor->cur_mode.bit_width == 8) {
+			*code = MEDIA_BUS_FMT_SGBRG8_1X8;
+		} else if (sensor->cur_mode.bit_width == 10) {
+			*code = MEDIA_BUS_FMT_SGBRG10_1X10;
+		} else {
+			*code = MEDIA_BUS_FMT_SGBRG12_1X12;
+		}
+		break;
+	case BAYER_BGGR:
+		if (sensor->cur_mode.bit_width == 8) {
+			*code = MEDIA_BUS_FMT_SBGGR8_1X8;
+		} else if (sensor->cur_mode.bit_width == 10) {
+			*code = MEDIA_BUS_FMT_SBGGR10_1X10;
+		} else {
+			*code = MEDIA_BUS_FMT_SBGGR12_1X12;
+		}
+		break;
+	default:
+		/*nothing need to do*/
+		break;
+	}
+	return 0;
+}
+
+
+static int ar0830_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ar0830 *sensor = client_to_ar0830(client);
+    int ret;
+	
+	pr_debug("enter %s\n", __func__);
+	if (enable) {
+        ret = ar0830_stream_on(sensor);
+        if (ret < 0)
+            return ret;
+    } else {
+        ret = ar0830_stream_off(sensor);
+        if (ret < 0)
+            return ret;
+    }
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 12, 0)
+static int ar0830_enum_mbus_code(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_state *state,
+				 struct v4l2_subdev_mbus_code_enum *code)
+#else
+static int ar0830_enum_mbus_code(struct v4l2_subdev *sd,
+			         struct v4l2_subdev_pad_config *cfg,
+			         struct v4l2_subdev_mbus_code_enum *code)
+#endif
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ar0830 *sensor = client_to_ar0830(client);
+
+	u32 cur_code = MEDIA_BUS_FMT_SBGGR12_1X12;
+
+	if (code->index > 0)
+		return -EINVAL;
+	ar0830_get_format_code(sensor,&cur_code);
+	code->code = cur_code;
+
+	return 0;
+}
+
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 12, 0)
+static int ar0830_set_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_state *state,
+			  struct v4l2_subdev_format *fmt)
+#else
+static int ar0830_set_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_pad_config *cfg,
+			  struct v4l2_subdev_format *fmt)
+
+#endif
+{
+	int ret = 0;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ar0830 *sensor = client_to_ar0830(client);
+
+	mutex_lock(&sensor->lock);
+	pr_info("enter %s\n", __func__);
+	if ((fmt->format.width != sensor->cur_mode.size.bounds_width) ||
+	    (fmt->format.height != sensor->cur_mode.size.bounds_height)) {
+		pr_err("%s:set sensor format %dx%d error\n",
+			__func__,fmt->format.width,fmt->format.height);
+		mutex_unlock(&sensor->lock);
+		return -EINVAL;
+	}
+	
+	ret |= ar0830_write_reg_arry(sensor,
+		sensor->cur_mode.preg_data,
+		sensor->cur_mode.reg_data_count);
+	
+	if (ret < 0) {
+		pr_err("%s:ar0830_write_reg_arry error\n",__func__);
+		mutex_unlock(&sensor->lock);
+		return -EINVAL;
+	}
+	ar0830_get_format_code(sensor, &fmt->format.code);
+	fmt->format.field = V4L2_FIELD_NONE;
+	sensor->format = fmt->format;
+	mutex_unlock(&sensor->lock);
+	return 0;
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 12, 0)
+static int ar0830_get_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_state *state,
+			  struct v4l2_subdev_format *fmt)
+#else
+static int ar0830_get_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_pad_config *cfg,
+			  struct v4l2_subdev_format *fmt)
+#endif
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ar0830 *sensor = client_to_ar0830(client);
+
+	mutex_lock(&sensor->lock);
+	fmt->format = sensor->format;
+	mutex_unlock(&sensor->lock);
+	return 0;
+}
+
+static long ar0830_priv_ioctl(struct v4l2_subdev *sd,
+                              unsigned int cmd,
+                              void *arg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ar0830 *sensor = client_to_ar0830(client);
+	long ret = 0;
+	struct vvcam_sccb_data_s sensor_reg;
+	uint32_t value = 0;
+
+	mutex_lock(&sensor->lock);
+	switch (cmd){
+	case VVSENSORIOC_S_POWER:
+		ret = 0;
+		break;
+	case VVSENSORIOC_S_CLK:
+		ret = 0;
+		break;
+	case VVSENSORIOC_G_CLK:
+		ret = ar0830_get_clk(sensor,arg);
+		break;
+	case VVSENSORIOC_RESET:
+		ret = 0;
+		break;
+	case VIDIOC_QUERYCAP:
+		ret = ar0830_query_capability(sensor, arg);
+		break;
+	case VVSENSORIOC_QUERY:
+		ret = ar0830_query_supports(sensor, arg);
+		break;
+	case VVSENSORIOC_G_CHIP_ID:
+		ret = ar0830_get_sensor_id(sensor, arg);
+		break;
+	case VVSENSORIOC_G_RESERVE_ID:
+		ret = ar0830_get_reserve_id(sensor, arg);
+		break;
+	case VVSENSORIOC_G_SENSOR_MODE:
+		ret = ar0830_get_sensor_mode(sensor, arg);
+		break;
+	case VVSENSORIOC_S_SENSOR_MODE:
+		ret = ar0830_set_sensor_mode(sensor, arg);
+		break;
+	case VVSENSORIOC_S_STREAM:
+		ret = copy_from_user(&value, arg, sizeof(value));
+		ret |= ar0830_s_stream(&sensor->subdev, value);
+		break;
+	case VVSENSORIOC_WRITE_REG:
+		ret = copy_from_user(&sensor_reg, arg,
+			sizeof(struct vvcam_sccb_data_s));
+		ret |= ar0830_write_reg(sensor, sensor_reg.addr,
+			sensor_reg.data);
+		break;
+	case VVSENSORIOC_READ_REG:
+		ret = copy_from_user(&sensor_reg, arg, sizeof(struct vvcam_sccb_data_s));
+		ret |= ar0830_read_reg(sensor, (u16)sensor_reg.addr, (u16 *)&sensor_reg.data);
+		ret |= copy_to_user(arg, &sensor_reg, sizeof(struct vvcam_sccb_data_s));
+		break;
+	case VVSENSORIOC_S_EXP:
+		ret = copy_from_user(&value, arg, sizeof(value));
+		ret |= ar0830_set_exp(sensor, value);
+		break;
+	case VVSENSORIOC_S_GAIN:
+		ret = copy_from_user(&value, arg, sizeof(value));
+		ret |= ar0830_set_gain(sensor, value);
+		break;
+	case VVSENSORIOC_S_FPS:
+		ret = copy_from_user(&value, arg, sizeof(value));
+		ret |= ar0830_set_fps(sensor, value);
+		break;
+	case VVSENSORIOC_G_FPS:
+		ret = ar0830_get_fps(sensor, &value);
+		ret |= copy_to_user(arg, &value, sizeof(value));
+		break;
+	case VVSENSORIOC_S_TEST_PATTERN:
+		ret= ar0830_set_test_pattern(sensor, arg);
+		break;
+	case VVSENSORIOC_G_LENS:
+		ret = ar0830_get_lens(sensor, arg);
+		break;
+	default:
+		break;
+	}
+
+	mutex_unlock(&sensor->lock);
+	return ret;
+}
+
+static struct v4l2_subdev_video_ops ar0830_subdev_video_ops = {
+	.s_stream = ar0830_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops ar0830_subdev_pad_ops = {
+	.enum_mbus_code = ar0830_enum_mbus_code,
+	.set_fmt = ar0830_set_fmt,
+	.get_fmt = ar0830_get_fmt,
+};
+
+static struct v4l2_subdev_core_ops ar0830_subdev_core_ops = {
+	.s_power = ar0830_s_power,
+	.ioctl = ar0830_priv_ioctl,
+};
+
+static struct v4l2_subdev_ops ar0830_subdev_ops = {
+	.core  = &ar0830_subdev_core_ops,
+	.video = &ar0830_subdev_video_ops,
+	.pad   = &ar0830_subdev_pad_ops,
+};
+
+static int ar0830_link_setup(struct media_entity *entity,
+			     const struct media_pad *local,
+			     const struct media_pad *remote, u32 flags)
+{
+	return 0;
+}
+
+static const struct media_entity_operations ar0830_sd_media_ops = {
+	.link_setup = ar0830_link_setup,
+};
+
+static int ar0830_regulator_enable(struct ar0830 *sensor)
+{
+	int ret = 0;
+	struct device *dev = &(sensor->i2c_client->dev);
+
+	pr_debug("enter %s\n", __func__);
+
+	if (sensor->io_regulator) {
+		regulator_set_voltage(sensor->io_regulator,
+				      AR0830_VOLTAGE_DIGITAL_IO,
+				      AR0830_VOLTAGE_DIGITAL_IO);
+		ret = regulator_enable(sensor->io_regulator);
+		if (ret < 0) {
+			dev_err(dev, "set io voltage failed\n");
+			return ret;
+		}
+	}
+
+	if (sensor->analog_regulator) {
+		regulator_set_voltage(sensor->analog_regulator,
+				      AR0830_VOLTAGE_ANALOG,
+				      AR0830_VOLTAGE_ANALOG);
+		ret = regulator_enable(sensor->analog_regulator);
+		if (ret) {
+			dev_err(dev, "set analog voltage failed\n");
+			goto err_disable_io;
+		}
+
+	}
+
+	if (sensor->core_regulator) {
+		regulator_set_voltage(sensor->core_regulator,
+				      AR0830_VOLTAGE_DIGITAL_CORE,
+				      AR0830_VOLTAGE_DIGITAL_CORE);
+		ret = regulator_enable(sensor->core_regulator);
+		if (ret) {
+			dev_err(dev, "set core voltage failed\n");
+			goto err_disable_analog;
+		}
+	}
+
+	return 0;
+
+err_disable_analog:
+	regulator_disable(sensor->analog_regulator);
+err_disable_io:
+	regulator_disable(sensor->io_regulator);
+	return ret;
+}
+
+static void ar0830_regulator_disable(struct ar0830 *sensor)
+{
+	int ret = 0;
+	struct device *dev = &(sensor->i2c_client->dev);
+
+	if (sensor->core_regulator) {
+		ret = regulator_disable(sensor->core_regulator);
+		if (ret < 0)
+			dev_err(dev, "core regulator disable failed\n");
+	}
+
+	if (sensor->analog_regulator) {
+		ret = regulator_disable(sensor->analog_regulator);
+		if (ret < 0)
+			dev_err(dev, "analog regulator disable failed\n");
+	}
+
+	if (sensor->io_regulator) {
+		ret = regulator_disable(sensor->io_regulator);
+		if (ret < 0)
+			dev_err(dev, "io regulator disable failed\n");
+	}
+	return ;
+}
+
+static int ar0830_set_clk_rate(struct ar0830 *sensor)
+{
+	int ret;
+	unsigned int clk;
+
+	clk = sensor->mclk;
+	clk = min_t(u32, clk, (u32)AR0830_XCLK_MAX);
+	clk = max_t(u32, clk, (u32)AR0830_XCLK_MIN);
+	sensor->mclk = clk;
+
+	pr_debug("   Setting mclk to %d MHz\n",sensor->mclk / 1000000);
+	ret = clk_set_rate(sensor->sensor_clk, sensor->mclk);
+	if (ret < 0)
+		pr_debug("set rate filed, rate=%d\n", sensor->mclk);
+	return ret;
+}
+
+static void ar0830_reset(struct ar0830 *sensor)
+{
+	pr_debug("enter %s\n", __func__);
+	if (!gpio_is_valid(sensor->rst_gpio))
+		return;
+
+	gpio_set_value_cansleep(sensor->rst_gpio, 0);
+	msleep(20);
+
+	gpio_set_value_cansleep(sensor->rst_gpio, 1);
+	msleep(20);
+
+	return;
+}
+static int ar0830_retrieve_capture_properties(
+			struct ar0830 *sensor,
+			struct ar0830_capture_properties* ocp)
+{
+	struct device *dev = &sensor->i2c_client->dev;
+	__u64 mlf = 0;
+	__u64 mpf = 0;
+	__u64 mdr = 0;
+
+	struct device_node *ep;
+	int ret;
+	/*Collecting the information about limits of capture path
+	* has been centralized to the sensor
+	* * also into the sensor endpoint itself.
+	*/
+
+	ep = of_graph_get_next_endpoint(dev->of_node, NULL);
+	if (!ep) {
+		dev_err(dev, "missing endpoint node\n");
+		return -ENODEV;
+	}
+
+	/*ret = fwnode_property_read_u64(of_fwnode_handle(ep),
+		"max-lane-frequency", &mlf);
+	if (ret || mlf == 0) {
+		dev_dbg(dev, "no limit for max-lane-frequency\n");
+	}*/
+	ret = fwnode_property_read_u64(of_fwnode_handle(ep),
+	        "max-pixel-frequency", &mpf);
+	if (ret || mpf == 0) {
+	        dev_dbg(dev, "no limit for max-pixel-frequency\n");
+	}
+
+	/*ret = fwnode_property_read_u64(of_fwnode_handle(ep),
+	        "max-data-rate", &mdr);
+	if (ret || mdr == 0) {
+	        dev_dbg(dev, "no limit for max-data_rate\n");
+	}*/
+
+	ocp->max_lane_frequency = mlf;
+	ocp->max_pixel_frequency = mpf;
+	ocp->max_data_rate = mdr;
+
+	return ret;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+static int ar0830_probe(struct i2c_client *client)
+#else
+static int ar0830_probe(struct i2c_client *client,
+                        const struct i2c_device_id *id)
+#endif
+{
+	int retval;
+	struct device *dev = &client->dev;
+	struct v4l2_subdev *sd;
+	struct ar0830 *sensor;
+    u16 chip_id;
+	struct device_node *lens_node;
+
+	pr_info("enter %s\n", __func__);
+
+	sensor = devm_kmalloc(dev, sizeof(*sensor), GFP_KERNEL);
+	if (!sensor)
+		return -ENOMEM;
+	memset(sensor, 0, sizeof(*sensor));
+
+	sensor->i2c_client = client;
+
+	sensor->pwn_gpio = of_get_named_gpio(dev->of_node, "pwn-gpios", 0);
+	if (!gpio_is_valid(sensor->pwn_gpio))
+		dev_warn(dev, "No sensor pwdn pin available");
+	else {
+		retval = devm_gpio_request_one(dev, sensor->pwn_gpio,
+						GPIOF_OUT_INIT_HIGH,
+						"ar0830_mipi_pwdn");
+		if (retval < 0) {
+			dev_warn(dev, "Failed to set power pin\n");
+			dev_warn(dev, "retval=%d\n", retval);
+			return retval;
+		}
+	}
+
+	sensor->rst_gpio = of_get_named_gpio(dev->of_node, "rst-gpios", 0);
+	if (!gpio_is_valid(sensor->rst_gpio))
+		dev_warn(dev, "No sensor reset pin available");
+	else {
+		retval = devm_gpio_request_one(dev, sensor->rst_gpio,
+						GPIOF_OUT_INIT_HIGH,
+						"ar0830_mipi_reset");
+		if (retval < 0) {
+			dev_warn(dev, "Failed to set reset pin\n");
+			return retval;
+		}
+	}
+
+	sensor->sensor_clk = devm_clk_get(dev, "csi_mclk");
+	if (IS_ERR(sensor->sensor_clk)) {
+		sensor->sensor_clk = NULL;
+		dev_err(dev, "clock-frequency missing or invalid\n");
+		return PTR_ERR(sensor->sensor_clk);
+	}
+
+	retval = of_property_read_u32(dev->of_node, "mclk", &(sensor->mclk));
+	if (retval) {
+		dev_err(dev, "mclk missing or invalid\n");
+		return retval;
+	}
+
+	retval = of_property_read_u32(dev->of_node, "mclk_source",
+				(u32 *)&(sensor->mclk_source));
+	if (retval) {
+		dev_err(dev, "mclk_source missing or invalid\n");
+		return retval;
+	}
+
+	retval = of_property_read_u32(dev->of_node, "csi_id", &(sensor->csi_id));
+	if (retval) {
+		dev_err(dev, "csi id missing or invalid\n");
+		return retval;
+	}
+
+	lens_node = of_parse_phandle(dev->of_node, "lens-focus", 0);
+	if (lens_node) {
+		retval = of_property_read_u32(lens_node, "id", &sensor->focus_lens.id);
+		if (retval) {
+			dev_err(dev, "lens-focus id missing or invalid\n");
+			return retval;
+		}
+		memcpy(sensor->focus_lens.name, lens_node->name, strlen(lens_node->name));
+	}
+
+	retval = ar0830_retrieve_capture_properties(sensor,&sensor->ocp);
+	if (retval) {
+		dev_warn(dev, "retrive capture properties error\n");
+	}
+
+	sensor->io_regulator = devm_regulator_get(dev, "DOVDD");
+	if (IS_ERR(sensor->io_regulator)) {
+		dev_err(dev, "cannot get io regulator\n");
+		return PTR_ERR(sensor->io_regulator);
+	}
+
+	sensor->core_regulator = devm_regulator_get(dev, "DVDD");
+	if (IS_ERR(sensor->core_regulator)) {
+		dev_err(dev, "cannot get core regulator\n");
+		return PTR_ERR(sensor->core_regulator);
+	}
+
+	sensor->analog_regulator = devm_regulator_get(dev, "AVDD");
+	if (IS_ERR(sensor->analog_regulator)) {
+		dev_err(dev, "cannot get analog  regulator\n");
+		return PTR_ERR(sensor->analog_regulator);
+	}
+
+	retval = ar0830_regulator_enable(sensor);
+	if (retval) {
+		dev_err(dev, "regulator enable failed\n");
+		return retval;
+	}
+
+	ar0830_set_clk_rate(sensor);
+	retval = clk_prepare_enable(sensor->sensor_clk);
+	if (retval < 0) {
+		dev_err(dev, "%s: enable sensor clk fail\n", __func__);
+		goto probe_err_regulator_disable;
+	}
+	mdelay(2);
+
+	retval = ar0830_power_on(sensor);
+	if (retval < 0) {
+		dev_err(dev, "%s: sensor power on fail\n", __func__);
+		goto probe_err_regulator_disable;
+	}
+
+	ar0830_reset(sensor);
+
+    ar0830_read_reg(sensor, AR0830_CHIP_VERSION_REG, &chip_id);
+	if (chip_id != AR0830_CHIP_ID) {
+		dev_err(dev, "Sensor AR0830 is not found\n");
+        goto probe_err_power_off;
+    }
+
+	sd = &sensor->subdev;
+	v4l2_i2c_subdev_init(sd, client, &ar0830_subdev_ops);
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	sd->dev = &client->dev;
+	sd->entity.ops = &ar0830_sd_media_ops;
+	sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	sensor->pads[AR0830_SENS_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	retval = media_entity_pads_init(&sd->entity,
+				AR0830_SENS_PADS_NUM,
+				sensor->pads);
+	if (retval < 0)
+		goto probe_err_power_off;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 12, 0)
+	retval = v4l2_async_register_subdev_sensor(sd);
+#else
+	retval = v4l2_async_register_subdev_sensor_common(sd);
+#endif
+	if (retval < 0) {
+		dev_err(&client->dev,"%s--Async register failed, ret=%d\n",
+			__func__,retval);
+		goto probe_err_free_entiny;
+	}
+
+	memcpy(&sensor->cur_mode, &par0830_mode_info[0],
+			sizeof(struct vvcam_mode_info_s));
+
+	mutex_init(&sensor->lock);
+
+	pr_info("%s camera mipi ar0830, is found\n", __func__);
+
+	return 0;
+
+probe_err_free_entiny:
+	media_entity_cleanup(&sd->entity);
+
+probe_err_power_off:
+	ar0830_power_off(sensor);
+
+probe_err_regulator_disable:
+	ar0830_regulator_disable(sensor);
+
+	return retval;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 0, 0)
+static int ar0830_remove(struct i2c_client *client)
+#else
+static void ar0830_remove(struct i2c_client *client)
+#endif
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ar0830 *sensor = client_to_ar0830(client);
+
+	pr_info("enter %s\n", __func__);
+
+	v4l2_async_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+	ar0830_power_off(sensor);
+	ar0830_regulator_disable(sensor);
+	mutex_destroy(&sensor->lock);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 0, 0)
+	return 0;
+#else
+#endif
+}
+
+static int __maybe_unused ar0830_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ar0830 *sensor = client_to_ar0830(client);
+
+	sensor->resume_status = sensor->stream_status;
+	if (sensor->resume_status) {
+		ar0830_s_stream(&sensor->subdev,0);
+	}
+
+	return 0;
+}
+
+static int __maybe_unused ar0830_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ar0830 *sensor = client_to_ar0830(client);
+
+	if (sensor->resume_status) {
+		ar0830_s_stream(&sensor->subdev,1);
+	}
+
+	return 0;
+}
+
+static const struct dev_pm_ops ar0830_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(ar0830_suspend, ar0830_resume)
+};
+
+static const struct i2c_device_id ar0830_id[] = {
+	{"ar0830", 0},
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, ar0830_id);
+
+static const struct of_device_id ar0830_of_match[] = {
+	{ .compatible = "onsemi,ar0830" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, ar0830_of_match);
+
+static struct i2c_driver ar0830_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name  = "ar0830",
+		.pm = &ar0830_pm_ops,
+		.of_match_table	= ar0830_of_match,
+	},
+	.probe  = ar0830_probe,
+	.remove = ar0830_remove,
+	.id_table = ar0830_id,
+};
+
+
+module_i2c_driver(ar0830_i2c_driver);
+MODULE_DESCRIPTION("AR0830 MIPI Camera Subdev Driver");
+MODULE_LICENSE("GPL");
diff --git a/vvcam/v4l2/sensor/ar0830/ar0830_regs_4k.h b/vvcam/v4l2/sensor/ar0830/ar0830_regs_4k.h
new file mode 100644
index 0000000..e826363
--- /dev/null
+++ b/vvcam/v4l2/sensor/ar0830/ar0830_regs_4k.h
@@ -0,0 +1,730 @@
+#ifndef _VVCAM_AR0830_REGS_LINEAR_4K_H_
+#define _VVCAM_AR0830_REGS_LINEAR_4K_H_
+
+#include "vvsensor.h"
+#define REG_DELAY				0xFFFE
+#define AR0830_REG_VALUE_08BIT		1
+#define AR0830_REG_VALUE_16BIT		2
+#define AR0830_REG_VALUE_24BIT		3
+/* 4K30 RAW10 */
+static struct vvcam_sccb_data_with_length_s ar0830_init_setting_linear_4k[] = {
+//static struct vvcam_sccb_data_s ar0830_init_setting_linear_4k[] = {
+{REG_DELAY, 2000},
+{0x0304, 0x0001, AR0830_REG_VALUE_16BIT},
+{0x0306, 0x003C, AR0830_REG_VALUE_16BIT},
+{0x0300, 0x0008, AR0830_REG_VALUE_16BIT},
+{0x0302, 0x0001, AR0830_REG_VALUE_16BIT},
+{0x030C, 0x0004, AR0830_REG_VALUE_16BIT},
+{0x030E, 0x0096, AR0830_REG_VALUE_16BIT},
+{0x0308, 0x000A, AR0830_REG_VALUE_16BIT},
+{0x030A, 0x0001, AR0830_REG_VALUE_16BIT},
+{0x3EC0, 0x0045, AR0830_REG_VALUE_16BIT},
+{0x3EC2, 0x0025, AR0830_REG_VALUE_16BIT},
+{0x3F02, 0x51CC, AR0830_REG_VALUE_16BIT},
+{0x3F04, 0x42E6, AR0830_REG_VALUE_16BIT},
+{0x3F06, 0x00CA, AR0830_REG_VALUE_16BIT},
+{0x3F08, 0x028A, AR0830_REG_VALUE_16BIT},
+{0x3F0A, 0x8488, AR0830_REG_VALUE_16BIT},
+{0x3F0C, 0x0006, AR0830_REG_VALUE_16BIT},
+{0x3F1C, 0x0CE2, AR0830_REG_VALUE_16BIT},
+{0x3F20, 0x8008, AR0830_REG_VALUE_16BIT},
+{0x44BE, 0x86E0, AR0830_REG_VALUE_16BIT},
+{0x44C0, 0x008A, AR0830_REG_VALUE_16BIT},
+{0x44C8, 0x2A41, AR0830_REG_VALUE_16BIT},
+{0x44CC, 0x7777, AR0830_REG_VALUE_16BIT},
+{0x44CA, 0x8A0E, AR0830_REG_VALUE_16BIT},
+{0x44CE, 0x8B64, AR0830_REG_VALUE_16BIT},
+{0x44D0, 0x175D, AR0830_REG_VALUE_16BIT},
+{0x44D2, 0x0B8F, AR0830_REG_VALUE_16BIT},
+{0x44D6, 0xB206, AR0830_REG_VALUE_16BIT},
+{0x44D8, 0xAAFA, AR0830_REG_VALUE_16BIT},
+{0x44DA, 0xC001, AR0830_REG_VALUE_16BIT},
+{0x340E, 0xA18B, AR0830_REG_VALUE_16BIT},
+{0x44DE, 0x34BF, AR0830_REG_VALUE_16BIT},
+{0x44E0, 0x3F3F, AR0830_REG_VALUE_16BIT},
+{0x44E2, 0x3F21, AR0830_REG_VALUE_16BIT},
+{0x32A4, 0x0000, AR0830_REG_VALUE_16BIT},
+{0x36C0, 0x0001, AR0830_REG_VALUE_16BIT},
+{0x44C6, 0x54E2, AR0830_REG_VALUE_16BIT},
+{0x44C4, 0x0FD0, AR0830_REG_VALUE_16BIT},
+{0x44BA, 0x3342, AR0830_REG_VALUE_16BIT},
+{0x4000, 0x011B, AR0830_REG_VALUE_16BIT},
+{0x4002, 0x212A, AR0830_REG_VALUE_16BIT},
+{0x4004, 0x45FF, AR0830_REG_VALUE_16BIT},
+{0x4006, 0xFFFF, AR0830_REG_VALUE_16BIT},
+{0x4008, 0x0810, AR0830_REG_VALUE_16BIT},
+{0x400A, 0x0225, AR0830_REG_VALUE_16BIT},
+{0x400C, 0x108F, AR0830_REG_VALUE_16BIT},
+{0x400E, 0x3003, AR0830_REG_VALUE_16BIT},
+{0x4010, 0x92F0, AR0830_REG_VALUE_16BIT},
+{0x4012, 0x0097, AR0830_REG_VALUE_16BIT},
+{0x4014, 0x30D8, AR0830_REG_VALUE_16BIT},
+{0x4016, 0xF007, AR0830_REG_VALUE_16BIT},
+{0x4018, 0x919A, AR0830_REG_VALUE_16BIT},
+{0x401A, 0xF001, AR0830_REG_VALUE_16BIT},
+{0x401C, 0x99F0, AR0830_REG_VALUE_16BIT},
+{0x401E, 0x0285, AR0830_REG_VALUE_16BIT},
+{0x4020, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x4022, 0x30C0, AR0830_REG_VALUE_16BIT},
+{0x4024, 0xF004, AR0830_REG_VALUE_16BIT},
+{0x4026, 0x8B89, AR0830_REG_VALUE_16BIT},
+{0x4028, 0xF007, AR0830_REG_VALUE_16BIT},
+{0x402A, 0x9CF0, AR0830_REG_VALUE_16BIT},
+{0x402C, 0x0082, AR0830_REG_VALUE_16BIT},
+{0x402E, 0x3018, AR0830_REG_VALUE_16BIT},
+{0x4030, 0x8BB1, AR0830_REG_VALUE_16BIT},
+{0x4032, 0xF001, AR0830_REG_VALUE_16BIT},
+{0x4034, 0xB6F0, AR0830_REG_VALUE_16BIT},
+{0x4036, 0x0021, AR0830_REG_VALUE_16BIT},
+{0x4038, 0x58F0, AR0830_REG_VALUE_16BIT},
+{0x403A, 0x0F99, AR0830_REG_VALUE_16BIT},
+{0x403C, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x403E, 0x98F0, AR0830_REG_VALUE_16BIT},
+{0x4040, 0x03A2, AR0830_REG_VALUE_16BIT},
+{0x4042, 0xF003, AR0830_REG_VALUE_16BIT},
+{0x4044, 0xA296, AR0830_REG_VALUE_16BIT},
+{0x4046, 0xB4F0, AR0830_REG_VALUE_16BIT},
+{0x4048, 0x029D, AR0830_REG_VALUE_16BIT},
+{0x404A, 0xF004, AR0830_REG_VALUE_16BIT},
+{0x404C, 0xA1F0, AR0830_REG_VALUE_16BIT},
+{0x404E, 0x20A1, AR0830_REG_VALUE_16BIT},
+{0x4050, 0xF004, AR0830_REG_VALUE_16BIT},
+{0x4052, 0x9DF0, AR0830_REG_VALUE_16BIT},
+{0x4054, 0x008B, AR0830_REG_VALUE_16BIT},
+{0x4056, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x4058, 0x1009, AR0830_REG_VALUE_16BIT},
+{0x405A, 0x83F0, AR0830_REG_VALUE_16BIT},
+{0x405C, 0x0088, AR0830_REG_VALUE_16BIT},
+{0x405E, 0xF002, AR0830_REG_VALUE_16BIT},
+{0x4060, 0x3600, AR0830_REG_VALUE_16BIT},
+{0x4062, 0xF003, AR0830_REG_VALUE_16BIT},
+{0x4064, 0x9088, AR0830_REG_VALUE_16BIT},
+{0x4066, 0xF004, AR0830_REG_VALUE_16BIT},
+{0x4068, 0x3600, AR0830_REG_VALUE_16BIT},
+{0x406A, 0x83F0, AR0830_REG_VALUE_16BIT},
+{0x406C, 0x138B, AR0830_REG_VALUE_16BIT},
+{0x406E, 0xF014, AR0830_REG_VALUE_16BIT},
+{0x4070, 0xA3F0, AR0830_REG_VALUE_16BIT},
+{0x4072, 0x03A3, AR0830_REG_VALUE_16BIT},
+{0x4074, 0xF004, AR0830_REG_VALUE_16BIT},
+{0x4076, 0x9DF0, AR0830_REG_VALUE_16BIT},
+{0x4078, 0x04A1, AR0830_REG_VALUE_16BIT},
+{0x407A, 0xF020, AR0830_REG_VALUE_16BIT},
+{0x407C, 0xA1F0, AR0830_REG_VALUE_16BIT},
+{0x407E, 0x4521, AR0830_REG_VALUE_16BIT},
+{0x4080, 0xEDB4, AR0830_REG_VALUE_16BIT},
+{0x4082, 0x40C2, AR0830_REG_VALUE_16BIT},
+{0x4084, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x4086, 0x1FF6, AR0830_REG_VALUE_16BIT},
+{0x4088, 0xF001, AR0830_REG_VALUE_16BIT},
+{0x408A, 0x3003, AR0830_REG_VALUE_16BIT},
+{0x408C, 0x84F0, AR0830_REG_VALUE_16BIT},
+{0x408E, 0x008B, AR0830_REG_VALUE_16BIT},
+{0x4090, 0xF007, AR0830_REG_VALUE_16BIT},
+{0x4092, 0x86F0, AR0830_REG_VALUE_16BIT},
+{0x4094, 0x0086, AR0830_REG_VALUE_16BIT},
+{0x4096, 0xF005, AR0830_REG_VALUE_16BIT},
+{0x4098, 0x8080, AR0830_REG_VALUE_16BIT},
+{0x409A, 0x8202, AR0830_REG_VALUE_16BIT},
+{0x409C, 0x0887, AR0830_REG_VALUE_16BIT},
+{0x409E, 0x30C0, AR0830_REG_VALUE_16BIT},
+{0x40A0, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x40A2, 0x3600, AR0830_REG_VALUE_16BIT},
+{0x40A4, 0xF010, AR0830_REG_VALUE_16BIT},
+{0x40A6, 0x3600, AR0830_REG_VALUE_16BIT},
+{0x40A8, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x40AA, 0x30C0, AR0830_REG_VALUE_16BIT},
+{0x40AC, 0x8702, AR0830_REG_VALUE_16BIT},
+{0x40AE, 0x0882, AR0830_REG_VALUE_16BIT},
+{0x40B0, 0x8080, AR0830_REG_VALUE_16BIT},
+{0x40B2, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x40B4, 0x8202, AR0830_REG_VALUE_16BIT},
+{0x40B6, 0x0887, AR0830_REG_VALUE_16BIT},
+{0x40B8, 0x30C0, AR0830_REG_VALUE_16BIT},
+{0x40BA, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x40BC, 0x3600, AR0830_REG_VALUE_16BIT},
+{0x40BE, 0xF00F, AR0830_REG_VALUE_16BIT},
+{0x40C0, 0x3600, AR0830_REG_VALUE_16BIT},
+{0x40C2, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x40C4, 0x30C0, AR0830_REG_VALUE_16BIT},
+{0x40C6, 0x8702, AR0830_REG_VALUE_16BIT},
+{0x40C8, 0x0882, AR0830_REG_VALUE_16BIT},
+{0x40CA, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x40CC, 0x80F0, AR0830_REG_VALUE_16BIT},
+{0x40CE, 0x439F, AR0830_REG_VALUE_16BIT},
+{0x40D0, 0x1300, AR0830_REG_VALUE_16BIT},
+{0x40D2, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x40D4, 0xB7E0, AR0830_REG_VALUE_16BIT},
+{0x40D6, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x40D8, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x40DA, 0x0401, AR0830_REG_VALUE_16BIT},
+{0x40DC, 0xF003, AR0830_REG_VALUE_16BIT},
+{0x40DE, 0x82F0, AR0830_REG_VALUE_16BIT},
+{0x40E0, 0x0302, AR0830_REG_VALUE_16BIT},
+{0x40E2, 0x0885, AR0830_REG_VALUE_16BIT},
+{0x40E4, 0xF015, AR0830_REG_VALUE_16BIT},
+{0x40E6, 0x8587, AR0830_REG_VALUE_16BIT},
+{0x40E8, 0xF033, AR0830_REG_VALUE_16BIT},
+{0x40EA, 0x87F1, AR0830_REG_VALUE_16BIT},
+{0x40EC, 0x8388, AR0830_REG_VALUE_16BIT},
+{0x40EE, 0xF005, AR0830_REG_VALUE_16BIT},
+{0x40F0, 0x88F0, AR0830_REG_VALUE_16BIT},
+{0x40F2, 0x0189, AR0830_REG_VALUE_16BIT},
+{0x40F4, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x40F6, 0x0048, AR0830_REG_VALUE_16BIT},
+{0x40F8, 0xF002, AR0830_REG_VALUE_16BIT},
+{0x40FA, 0x86F0, AR0830_REG_VALUE_16BIT},
+{0x40FC, 0x0482, AR0830_REG_VALUE_16BIT},
+{0x40FE, 0xF017, AR0830_REG_VALUE_16BIT},
+{0x4100, 0x8AF0, AR0830_REG_VALUE_16BIT},
+{0x4102, 0x1780, AR0830_REG_VALUE_16BIT},
+{0x4104, 0xF004, AR0830_REG_VALUE_16BIT},
+{0x4106, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4108, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x410A, 0x0401, AR0830_REG_VALUE_16BIT},
+{0x410C, 0xF015, AR0830_REG_VALUE_16BIT},
+{0x410E, 0x020C, AR0830_REG_VALUE_16BIT},
+{0x4110, 0xF016, AR0830_REG_VALUE_16BIT},
+{0x4112, 0x87F0, AR0830_REG_VALUE_16BIT},
+{0x4114, 0x0287, AR0830_REG_VALUE_16BIT},
+{0x4116, 0xF061, AR0830_REG_VALUE_16BIT},
+{0x4118, 0xE839, AR0830_REG_VALUE_16BIT},
+{0x411A, 0x20F0, AR0830_REG_VALUE_16BIT},
+{0x411C, 0x0534, AR0830_REG_VALUE_16BIT},
+{0x411E, 0x90F0, AR0830_REG_VALUE_16BIT},
+{0x4120, 0x0032, AR0830_REG_VALUE_16BIT},
+{0x4122, 0x48F0, AR0830_REG_VALUE_16BIT},
+{0x4124, 0x0039, AR0830_REG_VALUE_16BIT},
+{0x4126, 0x20F0, AR0830_REG_VALUE_16BIT},
+{0x4128, 0x0E39, AR0830_REG_VALUE_16BIT},
+{0x412A, 0x20F0, AR0830_REG_VALUE_16BIT},
+{0x412C, 0x0032, AR0830_REG_VALUE_16BIT},
+{0x412E, 0x48F0, AR0830_REG_VALUE_16BIT},
+{0x4130, 0x0034, AR0830_REG_VALUE_16BIT},
+{0x4132, 0x90F0, AR0830_REG_VALUE_16BIT},
+{0x4134, 0x05C1, AR0830_REG_VALUE_16BIT},
+{0x4136, 0x1BF0, AR0830_REG_VALUE_16BIT},
+{0x4138, 0x0439, AR0830_REG_VALUE_16BIT},
+{0x413A, 0x20F0, AR0830_REG_VALUE_16BIT},
+{0x413C, 0x03B0, AR0830_REG_VALUE_16BIT},
+{0x413E, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x4140, 0x0208, AR0830_REG_VALUE_16BIT},
+{0x4142, 0xF0AA, AR0830_REG_VALUE_16BIT},
+{0x4144, 0xB0F0, AR0830_REG_VALUE_16BIT},
+{0x4146, 0x1CE9, AR0830_REG_VALUE_16BIT},
+{0x4148, 0x8A00, AR0830_REG_VALUE_16BIT},
+{0x414A, 0x05F0, AR0830_REG_VALUE_16BIT},
+{0x414C, 0x93E0, AR0830_REG_VALUE_16BIT},
+{0x414E, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4150, 0xF063, AR0830_REG_VALUE_16BIT},
+{0x4152, 0x0830, AR0830_REG_VALUE_16BIT},
+{0x4154, 0x0205, AR0830_REG_VALUE_16BIT},
+{0x4156, 0x108F, AR0830_REG_VALUE_16BIT},
+{0x4158, 0x3003, AR0830_REG_VALUE_16BIT},
+{0x415A, 0x92F0, AR0830_REG_VALUE_16BIT},
+{0x415C, 0x0097, AR0830_REG_VALUE_16BIT},
+{0x415E, 0x30D8, AR0830_REG_VALUE_16BIT},
+{0x4160, 0xF007, AR0830_REG_VALUE_16BIT},
+{0x4162, 0x919A, AR0830_REG_VALUE_16BIT},
+{0x4164, 0xF001, AR0830_REG_VALUE_16BIT},
+{0x4166, 0x99F0, AR0830_REG_VALUE_16BIT},
+{0x4168, 0x0285, AR0830_REG_VALUE_16BIT},
+{0x416A, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x416C, 0x30C0, AR0830_REG_VALUE_16BIT},
+{0x416E, 0xF004, AR0830_REG_VALUE_16BIT},
+{0x4170, 0x8B89, AR0830_REG_VALUE_16BIT},
+{0x4172, 0xF007, AR0830_REG_VALUE_16BIT},
+{0x4174, 0x9CF0, AR0830_REG_VALUE_16BIT},
+{0x4176, 0x0082, AR0830_REG_VALUE_16BIT},
+{0x4178, 0x3018, AR0830_REG_VALUE_16BIT},
+{0x417A, 0x8BB1, AR0830_REG_VALUE_16BIT},
+{0x417C, 0xF001, AR0830_REG_VALUE_16BIT},
+{0x417E, 0xB6F0, AR0830_REG_VALUE_16BIT},
+{0x4180, 0x009C, AR0830_REG_VALUE_16BIT},
+{0x4182, 0xF00F, AR0830_REG_VALUE_16BIT},
+{0x4184, 0x99F0, AR0830_REG_VALUE_16BIT},
+{0x4186, 0x0098, AR0830_REG_VALUE_16BIT},
+{0x4188, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x418A, 0x2148, AR0830_REG_VALUE_16BIT},
+{0x418C, 0xF001, AR0830_REG_VALUE_16BIT},
+{0x418E, 0xA2F0, AR0830_REG_VALUE_16BIT},
+{0x4190, 0x03A2, AR0830_REG_VALUE_16BIT},
+{0x4192, 0x96B4, AR0830_REG_VALUE_16BIT},
+{0x4194, 0xF002, AR0830_REG_VALUE_16BIT},
+{0x4196, 0x9DF0, AR0830_REG_VALUE_16BIT},
+{0x4198, 0x04A1, AR0830_REG_VALUE_16BIT},
+{0x419A, 0xF020, AR0830_REG_VALUE_16BIT},
+{0x419C, 0xA1F0, AR0830_REG_VALUE_16BIT},
+{0x419E, 0x049D, AR0830_REG_VALUE_16BIT},
+{0x41A0, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x41A2, 0x8BF0, AR0830_REG_VALUE_16BIT},
+{0x41A4, 0x0010, AR0830_REG_VALUE_16BIT},
+{0x41A6, 0x0983, AR0830_REG_VALUE_16BIT},
+{0x41A8, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x41AA, 0x88F0, AR0830_REG_VALUE_16BIT},
+{0x41AC, 0x0236, AR0830_REG_VALUE_16BIT},
+{0x41AE, 0x00F0, AR0830_REG_VALUE_16BIT},
+{0x41B0, 0x0390, AR0830_REG_VALUE_16BIT},
+{0x41B2, 0x88F0, AR0830_REG_VALUE_16BIT},
+{0x41B4, 0x0436, AR0830_REG_VALUE_16BIT},
+{0x41B6, 0x0083, AR0830_REG_VALUE_16BIT},
+{0x41B8, 0xF013, AR0830_REG_VALUE_16BIT},
+{0x41BA, 0x8BF0, AR0830_REG_VALUE_16BIT},
+{0x41BC, 0x14A3, AR0830_REG_VALUE_16BIT},
+{0x41BE, 0xF003, AR0830_REG_VALUE_16BIT},
+{0x41C0, 0xA3F0, AR0830_REG_VALUE_16BIT},
+{0x41C2, 0x049D, AR0830_REG_VALUE_16BIT},
+{0x41C4, 0xF004, AR0830_REG_VALUE_16BIT},
+{0x41C6, 0xA1F0, AR0830_REG_VALUE_16BIT},
+{0x41C8, 0x20A1, AR0830_REG_VALUE_16BIT},
+{0x41CA, 0xF045, AR0830_REG_VALUE_16BIT},
+{0x41CC, 0x21ED, AR0830_REG_VALUE_16BIT},
+{0x41CE, 0xB440, AR0830_REG_VALUE_16BIT},
+{0x41D0, 0xC284, AR0830_REG_VALUE_16BIT},
+{0x41D2, 0x1FF6, AR0830_REG_VALUE_16BIT},
+{0x41D4, 0x0840, AR0830_REG_VALUE_16BIT},
+{0x41D6, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x41D8, 0x3003, AR0830_REG_VALUE_16BIT},
+{0x41DA, 0x86F0, AR0830_REG_VALUE_16BIT},
+{0x41DC, 0x0080, AR0830_REG_VALUE_16BIT},
+{0x41DE, 0x8082, AR0830_REG_VALUE_16BIT},
+{0x41E0, 0x0208, AR0830_REG_VALUE_16BIT},
+{0x41E2, 0x8736, AR0830_REG_VALUE_16BIT},
+{0x41E4, 0xC0F0, AR0830_REG_VALUE_16BIT},
+{0x41E6, 0x0236, AR0830_REG_VALUE_16BIT},
+{0x41E8, 0xC087, AR0830_REG_VALUE_16BIT},
+{0x41EA, 0x0208, AR0830_REG_VALUE_16BIT},
+{0x41EC, 0x8280, AR0830_REG_VALUE_16BIT},
+{0x41EE, 0x8082, AR0830_REG_VALUE_16BIT},
+{0x41F0, 0x0208, AR0830_REG_VALUE_16BIT},
+{0x41F2, 0x8736, AR0830_REG_VALUE_16BIT},
+{0x41F4, 0xC0F0, AR0830_REG_VALUE_16BIT},
+{0x41F6, 0x0236, AR0830_REG_VALUE_16BIT},
+{0x41F8, 0xC087, AR0830_REG_VALUE_16BIT},
+{0x41FA, 0x0208, AR0830_REG_VALUE_16BIT},
+{0x41FC, 0x8280, AR0830_REG_VALUE_16BIT},
+{0x41FE, 0x8082, AR0830_REG_VALUE_16BIT},
+{0x4200, 0x0208, AR0830_REG_VALUE_16BIT},
+{0x4202, 0x8736, AR0830_REG_VALUE_16BIT},
+{0x4204, 0xC0F0, AR0830_REG_VALUE_16BIT},
+{0x4206, 0x0236, AR0830_REG_VALUE_16BIT},
+{0x4208, 0xC087, AR0830_REG_VALUE_16BIT},
+{0x420A, 0x0208, AR0830_REG_VALUE_16BIT},
+{0x420C, 0x8280, AR0830_REG_VALUE_16BIT},
+{0x420E, 0x8082, AR0830_REG_VALUE_16BIT},
+{0x4210, 0x0208, AR0830_REG_VALUE_16BIT},
+{0x4212, 0x8736, AR0830_REG_VALUE_16BIT},
+{0x4214, 0xC0F0, AR0830_REG_VALUE_16BIT},
+{0x4216, 0x0236, AR0830_REG_VALUE_16BIT},
+{0x4218, 0xC087, AR0830_REG_VALUE_16BIT},
+{0x421A, 0x9F13, AR0830_REG_VALUE_16BIT},
+{0x421C, 0x0002, AR0830_REG_VALUE_16BIT},
+{0x421E, 0x0DB7, AR0830_REG_VALUE_16BIT},
+{0x4220, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4222, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4224, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4226, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4228, 0xF013, AR0830_REG_VALUE_16BIT},
+{0x422A, 0x80F0, AR0830_REG_VALUE_16BIT},
+{0x422C, 0x3102, AR0830_REG_VALUE_16BIT},
+{0x422E, 0x3410, AR0830_REG_VALUE_16BIT},
+{0x4230, 0xCF30, AR0830_REG_VALUE_16BIT},
+{0x4232, 0x03F0, AR0830_REG_VALUE_16BIT},
+{0x4234, 0x00B2, AR0830_REG_VALUE_16BIT},
+{0x4236, 0x30C0, AR0830_REG_VALUE_16BIT},
+{0x4238, 0x3018, AR0830_REG_VALUE_16BIT},
+{0x423A, 0x97B5, AR0830_REG_VALUE_16BIT},
+{0x423C, 0xF004, AR0830_REG_VALUE_16BIT},
+{0x423E, 0x91F0, AR0830_REG_VALUE_16BIT},
+{0x4240, 0x009A, AR0830_REG_VALUE_16BIT},
+{0x4242, 0xF001, AR0830_REG_VALUE_16BIT},
+{0x4244, 0x99F0, AR0830_REG_VALUE_16BIT},
+{0x4246, 0x0330, AR0830_REG_VALUE_16BIT},
+{0x4248, 0x18F0, AR0830_REG_VALUE_16BIT},
+{0x424A, 0x0085, AR0830_REG_VALUE_16BIT},
+{0x424C, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x424E, 0x30C0, AR0830_REG_VALUE_16BIT},
+{0x4250, 0x9E40, AR0830_REG_VALUE_16BIT},
+{0x4252, 0x4220, AR0830_REG_VALUE_16BIT},
+{0x4254, 0x1889, AR0830_REG_VALUE_16BIT},
+{0x4256, 0x4104, AR0830_REG_VALUE_16BIT},
+{0x4258, 0x82A0, AR0830_REG_VALUE_16BIT},
+{0x425A, 0xF002, AR0830_REG_VALUE_16BIT},
+{0x425C, 0x8B9C, AR0830_REG_VALUE_16BIT},
+{0x425E, 0xF010, AR0830_REG_VALUE_16BIT},
+{0x4260, 0x99F0, AR0830_REG_VALUE_16BIT},
+{0x4262, 0x0098, AR0830_REG_VALUE_16BIT},
+{0x4264, 0xF003, AR0830_REG_VALUE_16BIT},
+{0x4266, 0xA296, AR0830_REG_VALUE_16BIT},
+{0x4268, 0xF001, AR0830_REG_VALUE_16BIT},
+{0x426A, 0xB4A2, AR0830_REG_VALUE_16BIT},
+{0x426C, 0xF004, AR0830_REG_VALUE_16BIT},
+{0x426E, 0x9DF0, AR0830_REG_VALUE_16BIT},
+{0x4270, 0x04A1, AR0830_REG_VALUE_16BIT},
+{0x4272, 0xF028, AR0830_REG_VALUE_16BIT},
+{0x4274, 0x8BA1, AR0830_REG_VALUE_16BIT},
+{0x4276, 0x1009, AR0830_REG_VALUE_16BIT},
+{0x4278, 0x83F0, AR0830_REG_VALUE_16BIT},
+{0x427A, 0x0136, AR0830_REG_VALUE_16BIT},
+{0x427C, 0x00F0, AR0830_REG_VALUE_16BIT},
+{0x427E, 0x009D, AR0830_REG_VALUE_16BIT},
+{0x4280, 0x88F0, AR0830_REG_VALUE_16BIT},
+{0x4282, 0x0888, AR0830_REG_VALUE_16BIT},
+{0x4284, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x4286, 0x3600, AR0830_REG_VALUE_16BIT},
+{0x4288, 0x8390, AR0830_REG_VALUE_16BIT},
+{0x428A, 0xF096, AR0830_REG_VALUE_16BIT},
+{0x428C, 0x8BF0, AR0830_REG_VALUE_16BIT},
+{0x428E, 0x0CA3, AR0830_REG_VALUE_16BIT},
+{0x4290, 0xF003, AR0830_REG_VALUE_16BIT},
+{0x4292, 0xA3F0, AR0830_REG_VALUE_16BIT},
+{0x4294, 0x049D, AR0830_REG_VALUE_16BIT},
+{0x4296, 0xF004, AR0830_REG_VALUE_16BIT},
+{0x4298, 0xA1F0, AR0830_REG_VALUE_16BIT},
+{0x429A, 0x20A1, AR0830_REG_VALUE_16BIT},
+{0x429C, 0xF043, AR0830_REG_VALUE_16BIT},
+{0x429E, 0x9DB4, AR0830_REG_VALUE_16BIT},
+{0x42A0, 0xF015, AR0830_REG_VALUE_16BIT},
+{0x42A2, 0x8B91, AR0830_REG_VALUE_16BIT},
+{0x42A4, 0x848E, AR0830_REG_VALUE_16BIT},
+{0x42A6, 0xF01E, AR0830_REG_VALUE_16BIT},
+{0x42A8, 0xB8F1, AR0830_REG_VALUE_16BIT},
+{0x42AA, 0xB3B2, AR0830_REG_VALUE_16BIT},
+{0x42AC, 0xF060, AR0830_REG_VALUE_16BIT},
+{0x42AE, 0xA6B9, AR0830_REG_VALUE_16BIT},
+{0x42B0, 0x848E, AR0830_REG_VALUE_16BIT},
+{0x42B2, 0xF004, AR0830_REG_VALUE_16BIT},
+{0x42B4, 0x0202, AR0830_REG_VALUE_16BIT},
+{0x42B6, 0xF015, AR0830_REG_VALUE_16BIT},
+{0x42B8, 0xB2F0, AR0830_REG_VALUE_16BIT},
+{0x42BA, 0x0691, AR0830_REG_VALUE_16BIT},
+{0x42BC, 0x83B8, AR0830_REG_VALUE_16BIT},
+{0x42BE, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x42C0, 0x3600, AR0830_REG_VALUE_16BIT},
+{0x42C2, 0xF00D, AR0830_REG_VALUE_16BIT},
+{0x42C4, 0x3600, AR0830_REG_VALUE_16BIT},
+{0x42C6, 0x83F0, AR0830_REG_VALUE_16BIT},
+{0x42C8, 0x029C, AR0830_REG_VALUE_16BIT},
+{0x42CA, 0xF008, AR0830_REG_VALUE_16BIT},
+{0x42CC, 0x9CF0, AR0830_REG_VALUE_16BIT},
+{0x42CE, 0x128B, AR0830_REG_VALUE_16BIT},
+{0x42D0, 0xF006, AR0830_REG_VALUE_16BIT},
+{0x42D2, 0x3018, AR0830_REG_VALUE_16BIT},
+{0x42D4, 0xA3F0, AR0830_REG_VALUE_16BIT},
+{0x42D6, 0x04A3, AR0830_REG_VALUE_16BIT},
+{0x42D8, 0xF003, AR0830_REG_VALUE_16BIT},
+{0x42DA, 0x9DF0, AR0830_REG_VALUE_16BIT},
+{0x42DC, 0x6A30, AR0830_REG_VALUE_16BIT},
+{0x42DE, 0x189D, AR0830_REG_VALUE_16BIT},
+{0x42E0, 0xF002, AR0830_REG_VALUE_16BIT},
+{0x42E2, 0x8BF0, AR0830_REG_VALUE_16BIT},
+{0x42E4, 0x0082, AR0830_REG_VALUE_16BIT},
+{0x42E6, 0xF004, AR0830_REG_VALUE_16BIT},
+{0x42E8, 0x30C0, AR0830_REG_VALUE_16BIT},
+{0x42EA, 0xF014, AR0830_REG_VALUE_16BIT},
+{0x42EC, 0x30C0, AR0830_REG_VALUE_16BIT},
+{0x42EE, 0xF004, AR0830_REG_VALUE_16BIT},
+{0x42F0, 0x82F0, AR0830_REG_VALUE_16BIT},
+{0x42F2, 0x0D90, AR0830_REG_VALUE_16BIT},
+{0x42F4, 0xF002, AR0830_REG_VALUE_16BIT},
+{0x42F6, 0x8BF0, AR0830_REG_VALUE_16BIT},
+{0x42F8, 0x018C, AR0830_REG_VALUE_16BIT},
+{0x42FA, 0x8FF0, AR0830_REG_VALUE_16BIT},
+{0x42FC, 0x3E30, AR0830_REG_VALUE_16BIT},
+{0x42FE, 0x18A2, AR0830_REG_VALUE_16BIT},
+{0x4300, 0xF003, AR0830_REG_VALUE_16BIT},
+{0x4302, 0xA2F0, AR0830_REG_VALUE_16BIT},
+{0x4304, 0x049D, AR0830_REG_VALUE_16BIT},
+{0x4306, 0xF036, AR0830_REG_VALUE_16BIT},
+{0x4308, 0x9DF0, AR0830_REG_VALUE_16BIT},
+{0x430A, 0x0A30, AR0830_REG_VALUE_16BIT},
+{0x430C, 0x1889, AR0830_REG_VALUE_16BIT},
+{0x430E, 0xB5F0, AR0830_REG_VALUE_16BIT},
+{0x4310, 0x018B, AR0830_REG_VALUE_16BIT},
+{0x4312, 0xF002, AR0830_REG_VALUE_16BIT},
+{0x4314, 0x97F0, AR0830_REG_VALUE_16BIT},
+{0x4316, 0x0017, AR0830_REG_VALUE_16BIT},
+{0x4318, 0xA621, AR0830_REG_VALUE_16BIT},
+{0x431A, 0xCD40, AR0830_REG_VALUE_16BIT},
+{0x431C, 0xC230, AR0830_REG_VALUE_16BIT},
+{0x431E, 0x0710, AR0830_REG_VALUE_16BIT},
+{0x4320, 0x4984, AR0830_REG_VALUE_16BIT},
+{0x4322, 0xF00C, AR0830_REG_VALUE_16BIT},
+{0x4324, 0x80F0, AR0830_REG_VALUE_16BIT},
+{0x4326, 0x1486, AR0830_REG_VALUE_16BIT},
+{0x4328, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x432A, 0x86F0, AR0830_REG_VALUE_16BIT},
+{0x432C, 0x0C80, AR0830_REG_VALUE_16BIT},
+{0x432E, 0x8283, AR0830_REG_VALUE_16BIT},
+{0x4330, 0x8730, AR0830_REG_VALUE_16BIT},
+{0x4332, 0xC036, AR0830_REG_VALUE_16BIT},
+{0x4334, 0x00F0, AR0830_REG_VALUE_16BIT},
+{0x4336, 0x1030, AR0830_REG_VALUE_16BIT},
+{0x4338, 0xC036, AR0830_REG_VALUE_16BIT},
+{0x433A, 0x0087, AR0830_REG_VALUE_16BIT},
+{0x433C, 0x8382, AR0830_REG_VALUE_16BIT},
+{0x433E, 0x8080, AR0830_REG_VALUE_16BIT},
+{0x4340, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x4342, 0x8283, AR0830_REG_VALUE_16BIT},
+{0x4344, 0x8730, AR0830_REG_VALUE_16BIT},
+{0x4346, 0xC036, AR0830_REG_VALUE_16BIT},
+{0x4348, 0x00F0, AR0830_REG_VALUE_16BIT},
+{0x434A, 0x0F30, AR0830_REG_VALUE_16BIT},
+{0x434C, 0xC0F0, AR0830_REG_VALUE_16BIT},
+{0x434E, 0x0036, AR0830_REG_VALUE_16BIT},
+{0x4350, 0x0087, AR0830_REG_VALUE_16BIT},
+{0x4352, 0x8382, AR0830_REG_VALUE_16BIT},
+{0x4354, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x4356, 0x80F1, AR0830_REG_VALUE_16BIT},
+{0x4358, 0xD9B8, AR0830_REG_VALUE_16BIT},
+{0x435A, 0xF00D, AR0830_REG_VALUE_16BIT},
+{0x435C, 0xB7F0, AR0830_REG_VALUE_16BIT},
+{0x435E, 0x019F, AR0830_REG_VALUE_16BIT},
+{0x4360, 0xF02B, AR0830_REG_VALUE_16BIT},
+{0x4362, 0x1300, AR0830_REG_VALUE_16BIT},
+{0x4364, 0xB981, AR0830_REG_VALUE_16BIT},
+{0x4366, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4368, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x436A, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x436C, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x436E, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4370, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4372, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4374, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4376, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4378, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x437A, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x437C, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x437E, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4380, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4382, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4384, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4386, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4388, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x438A, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x438C, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x438E, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4390, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4392, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4394, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4396, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4398, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x439A, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x439C, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x439E, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43A0, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43A2, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43A4, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43A6, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43A8, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43AA, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43AC, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43AE, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43B0, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43B2, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43B4, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43B6, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43B8, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43BA, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43BC, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43BE, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43C0, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43C2, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43C4, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43C6, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43C8, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43CA, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43CC, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43CE, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43D0, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43D2, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43D4, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43D6, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43D8, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43DA, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43DC, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43DE, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43E0, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43E2, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43E4, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43E6, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43E8, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43EA, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43EC, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43EE, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43F0, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43F2, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43F4, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43F6, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43F8, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43FA, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43FC, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43FE, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4400, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4402, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4404, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4406, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4408, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x440A, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x440C, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x440E, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4410, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4412, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4414, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4416, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4418, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x441A, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x441C, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x441E, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4420, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4422, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4424, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4426, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4428, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x442A, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x442C, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x442E, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4430, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4432, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4434, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4436, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4438, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x443A, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x443C, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x443E, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4440, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4442, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4444, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4446, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4448, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x444A, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x444C, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x444E, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4450, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4452, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4454, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4456, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4458, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x445A, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x445C, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x445E, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4460, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4462, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4464, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4466, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4468, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x446A, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x446C, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x446E, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4470, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4472, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4474, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4476, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4478, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x447A, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x447C, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x447E, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4480, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4482, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4484, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4486, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4488, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x448A, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x448C, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x448E, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4490, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4492, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4494, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4496, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4498, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x449A, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x449C, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x449E, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x44A0, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x44A2, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x44A4, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x44A6, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x44A8, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x44AA, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x44AC, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x44AE, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x44B0, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x44B2, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x44B4, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x3980, 0x0001, AR0830_REG_VALUE_16BIT},
+{0x3340, 0x0C60, AR0830_REG_VALUE_16BIT},
+{0x3F7C, 0x0001, AR0830_REG_VALUE_16BIT},
+{0x0344, 0x0008, AR0830_REG_VALUE_16BIT},
+{0x0348, 0x0F07, AR0830_REG_VALUE_16BIT},
+{0x0346, 0x0008, AR0830_REG_VALUE_16BIT},
+{0x034A, 0x0877, AR0830_REG_VALUE_16BIT},
+{0x034C, 0x0F00, AR0830_REG_VALUE_16BIT},
+{0x034E, 0x0870, AR0830_REG_VALUE_16BIT},
+{0x0380, 0x0001, AR0830_REG_VALUE_16BIT},
+{0x0382, 0x0001, AR0830_REG_VALUE_16BIT},
+{0x0384, 0x0001, AR0830_REG_VALUE_16BIT},
+{0x0386, 0x0001, AR0830_REG_VALUE_16BIT},
+{0x0900, 0x00  , AR0830_REG_VALUE_08BIT},
+{0x0901, 0x11  , AR0830_REG_VALUE_08BIT},
+{0x0342, 0x2340, AR0830_REG_VALUE_16BIT},
+{0x0340, 0x08A8, AR0830_REG_VALUE_16BIT},
+{0x0202, 0x0884, AR0830_REG_VALUE_16BIT},
+{0x020E, 0x0100, AR0830_REG_VALUE_16BIT},
+{0x0204, 0x0000, AR0830_REG_VALUE_16BIT},
+{0x0112, 0x0A0A, AR0830_REG_VALUE_16BIT},
+{0x3EC4, 0x0204, AR0830_REG_VALUE_16BIT},
+{0x3EC6, 0x0000, AR0830_REG_VALUE_16BIT},
+{0x3600, 0x94D8, AR0830_REG_VALUE_16BIT},
+{0x5500, 0x0000, AR0830_REG_VALUE_16BIT},
+{0x5502, 0x0001, AR0830_REG_VALUE_16BIT},
+{0x5504, 0x0006, AR0830_REG_VALUE_16BIT},
+{0x5506, 0x0008, AR0830_REG_VALUE_16BIT},
+{0x5508, 0x000F, AR0830_REG_VALUE_16BIT},
+{0x550A, 0x0010, AR0830_REG_VALUE_16BIT},
+{0x550C, 0x0011, AR0830_REG_VALUE_16BIT},
+{0x550E, 0x0012, AR0830_REG_VALUE_16BIT},
+{0x5510, 0x0016, AR0830_REG_VALUE_16BIT},
+{0x5512, 0x0018, AR0830_REG_VALUE_16BIT},
+{0x5514, 0x0021, AR0830_REG_VALUE_16BIT},
+{0x5516, 0x0023, AR0830_REG_VALUE_16BIT},
+{0x5518, 0x0026, AR0830_REG_VALUE_16BIT},
+{0x551A, 0x0028, AR0830_REG_VALUE_16BIT},
+{0x551C, 0x002F, AR0830_REG_VALUE_16BIT},
+{0x551E, 0x0030, AR0830_REG_VALUE_16BIT},
+{0x5400, 0x0100, AR0830_REG_VALUE_16BIT},
+{0x5402, 0x2106, AR0830_REG_VALUE_16BIT},
+{0x5404, 0x1103, AR0830_REG_VALUE_16BIT},
+{0x5406, 0x3103, AR0830_REG_VALUE_16BIT},
+{0x5408, 0x6103, AR0830_REG_VALUE_16BIT},
+{0x540A, 0x9103, AR0830_REG_VALUE_16BIT},
+{0x540C, 0xA103, AR0830_REG_VALUE_16BIT},
+{0x540E, 0xD103, AR0830_REG_VALUE_16BIT},
+{0x5410, 0xF110, AR0830_REG_VALUE_16BIT},
+{0x5412, 0xE102, AR0830_REG_VALUE_16BIT},
+{0x5414, 0xF15E, AR0830_REG_VALUE_16BIT},
+{0x5416, 0xF1EE, AR0830_REG_VALUE_16BIT},
+{0x5418, 0xF2BA, AR0830_REG_VALUE_16BIT},
+{0x541A, 0xF3DA, AR0830_REG_VALUE_16BIT},
+{0x541C, 0xF571, AR0830_REG_VALUE_16BIT},
+{0x541E, 0xF7B0, AR0830_REG_VALUE_16BIT},
+{0x5420, 0xFADD, AR0830_REG_VALUE_16BIT},
+{0x5422, 0xFF58, AR0830_REG_VALUE_16BIT},
+{0x5424, 0xFFFA, AR0830_REG_VALUE_16BIT},
+{0x5426, 0x5557, AR0830_REG_VALUE_16BIT},
+{0x5428, 0x0005, AR0830_REG_VALUE_16BIT},
+{0x542A, 0xA550, AR0830_REG_VALUE_16BIT},
+{0x542C, 0xAAAA, AR0830_REG_VALUE_16BIT},
+{0x542E, 0x000A, AR0830_REG_VALUE_16BIT},
+{0x5460, 0x2269, AR0830_REG_VALUE_16BIT},
+{0x5462, 0x0B8F, AR0830_REG_VALUE_16BIT},
+{0x5464, 0x0B8F, AR0830_REG_VALUE_16BIT},
+{0x5466, 0x098B, AR0830_REG_VALUE_16BIT},
+{0x5498, 0x2263, AR0830_REG_VALUE_16BIT},
+{0x549A, 0x54E2, AR0830_REG_VALUE_16BIT},
+{0x549C, 0x54E3, AR0830_REG_VALUE_16BIT},
+{0x549E, 0x54E3, AR0830_REG_VALUE_16BIT},
+{0x3060, 0xFF01, AR0830_REG_VALUE_16BIT},
+{REG_DELAY, 200},
+};
+
+#endif
diff --git a/vvcam/v4l2/sensor/ar0830/ar0830_regs_4k.h.orig b/vvcam/v4l2/sensor/ar0830/ar0830_regs_4k.h.orig
new file mode 100644
index 0000000..e826363
--- /dev/null
+++ b/vvcam/v4l2/sensor/ar0830/ar0830_regs_4k.h.orig
@@ -0,0 +1,730 @@
+#ifndef _VVCAM_AR0830_REGS_LINEAR_4K_H_
+#define _VVCAM_AR0830_REGS_LINEAR_4K_H_
+
+#include "vvsensor.h"
+#define REG_DELAY				0xFFFE
+#define AR0830_REG_VALUE_08BIT		1
+#define AR0830_REG_VALUE_16BIT		2
+#define AR0830_REG_VALUE_24BIT		3
+/* 4K30 RAW10 */
+static struct vvcam_sccb_data_with_length_s ar0830_init_setting_linear_4k[] = {
+//static struct vvcam_sccb_data_s ar0830_init_setting_linear_4k[] = {
+{REG_DELAY, 2000},
+{0x0304, 0x0001, AR0830_REG_VALUE_16BIT},
+{0x0306, 0x003C, AR0830_REG_VALUE_16BIT},
+{0x0300, 0x0008, AR0830_REG_VALUE_16BIT},
+{0x0302, 0x0001, AR0830_REG_VALUE_16BIT},
+{0x030C, 0x0004, AR0830_REG_VALUE_16BIT},
+{0x030E, 0x0096, AR0830_REG_VALUE_16BIT},
+{0x0308, 0x000A, AR0830_REG_VALUE_16BIT},
+{0x030A, 0x0001, AR0830_REG_VALUE_16BIT},
+{0x3EC0, 0x0045, AR0830_REG_VALUE_16BIT},
+{0x3EC2, 0x0025, AR0830_REG_VALUE_16BIT},
+{0x3F02, 0x51CC, AR0830_REG_VALUE_16BIT},
+{0x3F04, 0x42E6, AR0830_REG_VALUE_16BIT},
+{0x3F06, 0x00CA, AR0830_REG_VALUE_16BIT},
+{0x3F08, 0x028A, AR0830_REG_VALUE_16BIT},
+{0x3F0A, 0x8488, AR0830_REG_VALUE_16BIT},
+{0x3F0C, 0x0006, AR0830_REG_VALUE_16BIT},
+{0x3F1C, 0x0CE2, AR0830_REG_VALUE_16BIT},
+{0x3F20, 0x8008, AR0830_REG_VALUE_16BIT},
+{0x44BE, 0x86E0, AR0830_REG_VALUE_16BIT},
+{0x44C0, 0x008A, AR0830_REG_VALUE_16BIT},
+{0x44C8, 0x2A41, AR0830_REG_VALUE_16BIT},
+{0x44CC, 0x7777, AR0830_REG_VALUE_16BIT},
+{0x44CA, 0x8A0E, AR0830_REG_VALUE_16BIT},
+{0x44CE, 0x8B64, AR0830_REG_VALUE_16BIT},
+{0x44D0, 0x175D, AR0830_REG_VALUE_16BIT},
+{0x44D2, 0x0B8F, AR0830_REG_VALUE_16BIT},
+{0x44D6, 0xB206, AR0830_REG_VALUE_16BIT},
+{0x44D8, 0xAAFA, AR0830_REG_VALUE_16BIT},
+{0x44DA, 0xC001, AR0830_REG_VALUE_16BIT},
+{0x340E, 0xA18B, AR0830_REG_VALUE_16BIT},
+{0x44DE, 0x34BF, AR0830_REG_VALUE_16BIT},
+{0x44E0, 0x3F3F, AR0830_REG_VALUE_16BIT},
+{0x44E2, 0x3F21, AR0830_REG_VALUE_16BIT},
+{0x32A4, 0x0000, AR0830_REG_VALUE_16BIT},
+{0x36C0, 0x0001, AR0830_REG_VALUE_16BIT},
+{0x44C6, 0x54E2, AR0830_REG_VALUE_16BIT},
+{0x44C4, 0x0FD0, AR0830_REG_VALUE_16BIT},
+{0x44BA, 0x3342, AR0830_REG_VALUE_16BIT},
+{0x4000, 0x011B, AR0830_REG_VALUE_16BIT},
+{0x4002, 0x212A, AR0830_REG_VALUE_16BIT},
+{0x4004, 0x45FF, AR0830_REG_VALUE_16BIT},
+{0x4006, 0xFFFF, AR0830_REG_VALUE_16BIT},
+{0x4008, 0x0810, AR0830_REG_VALUE_16BIT},
+{0x400A, 0x0225, AR0830_REG_VALUE_16BIT},
+{0x400C, 0x108F, AR0830_REG_VALUE_16BIT},
+{0x400E, 0x3003, AR0830_REG_VALUE_16BIT},
+{0x4010, 0x92F0, AR0830_REG_VALUE_16BIT},
+{0x4012, 0x0097, AR0830_REG_VALUE_16BIT},
+{0x4014, 0x30D8, AR0830_REG_VALUE_16BIT},
+{0x4016, 0xF007, AR0830_REG_VALUE_16BIT},
+{0x4018, 0x919A, AR0830_REG_VALUE_16BIT},
+{0x401A, 0xF001, AR0830_REG_VALUE_16BIT},
+{0x401C, 0x99F0, AR0830_REG_VALUE_16BIT},
+{0x401E, 0x0285, AR0830_REG_VALUE_16BIT},
+{0x4020, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x4022, 0x30C0, AR0830_REG_VALUE_16BIT},
+{0x4024, 0xF004, AR0830_REG_VALUE_16BIT},
+{0x4026, 0x8B89, AR0830_REG_VALUE_16BIT},
+{0x4028, 0xF007, AR0830_REG_VALUE_16BIT},
+{0x402A, 0x9CF0, AR0830_REG_VALUE_16BIT},
+{0x402C, 0x0082, AR0830_REG_VALUE_16BIT},
+{0x402E, 0x3018, AR0830_REG_VALUE_16BIT},
+{0x4030, 0x8BB1, AR0830_REG_VALUE_16BIT},
+{0x4032, 0xF001, AR0830_REG_VALUE_16BIT},
+{0x4034, 0xB6F0, AR0830_REG_VALUE_16BIT},
+{0x4036, 0x0021, AR0830_REG_VALUE_16BIT},
+{0x4038, 0x58F0, AR0830_REG_VALUE_16BIT},
+{0x403A, 0x0F99, AR0830_REG_VALUE_16BIT},
+{0x403C, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x403E, 0x98F0, AR0830_REG_VALUE_16BIT},
+{0x4040, 0x03A2, AR0830_REG_VALUE_16BIT},
+{0x4042, 0xF003, AR0830_REG_VALUE_16BIT},
+{0x4044, 0xA296, AR0830_REG_VALUE_16BIT},
+{0x4046, 0xB4F0, AR0830_REG_VALUE_16BIT},
+{0x4048, 0x029D, AR0830_REG_VALUE_16BIT},
+{0x404A, 0xF004, AR0830_REG_VALUE_16BIT},
+{0x404C, 0xA1F0, AR0830_REG_VALUE_16BIT},
+{0x404E, 0x20A1, AR0830_REG_VALUE_16BIT},
+{0x4050, 0xF004, AR0830_REG_VALUE_16BIT},
+{0x4052, 0x9DF0, AR0830_REG_VALUE_16BIT},
+{0x4054, 0x008B, AR0830_REG_VALUE_16BIT},
+{0x4056, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x4058, 0x1009, AR0830_REG_VALUE_16BIT},
+{0x405A, 0x83F0, AR0830_REG_VALUE_16BIT},
+{0x405C, 0x0088, AR0830_REG_VALUE_16BIT},
+{0x405E, 0xF002, AR0830_REG_VALUE_16BIT},
+{0x4060, 0x3600, AR0830_REG_VALUE_16BIT},
+{0x4062, 0xF003, AR0830_REG_VALUE_16BIT},
+{0x4064, 0x9088, AR0830_REG_VALUE_16BIT},
+{0x4066, 0xF004, AR0830_REG_VALUE_16BIT},
+{0x4068, 0x3600, AR0830_REG_VALUE_16BIT},
+{0x406A, 0x83F0, AR0830_REG_VALUE_16BIT},
+{0x406C, 0x138B, AR0830_REG_VALUE_16BIT},
+{0x406E, 0xF014, AR0830_REG_VALUE_16BIT},
+{0x4070, 0xA3F0, AR0830_REG_VALUE_16BIT},
+{0x4072, 0x03A3, AR0830_REG_VALUE_16BIT},
+{0x4074, 0xF004, AR0830_REG_VALUE_16BIT},
+{0x4076, 0x9DF0, AR0830_REG_VALUE_16BIT},
+{0x4078, 0x04A1, AR0830_REG_VALUE_16BIT},
+{0x407A, 0xF020, AR0830_REG_VALUE_16BIT},
+{0x407C, 0xA1F0, AR0830_REG_VALUE_16BIT},
+{0x407E, 0x4521, AR0830_REG_VALUE_16BIT},
+{0x4080, 0xEDB4, AR0830_REG_VALUE_16BIT},
+{0x4082, 0x40C2, AR0830_REG_VALUE_16BIT},
+{0x4084, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x4086, 0x1FF6, AR0830_REG_VALUE_16BIT},
+{0x4088, 0xF001, AR0830_REG_VALUE_16BIT},
+{0x408A, 0x3003, AR0830_REG_VALUE_16BIT},
+{0x408C, 0x84F0, AR0830_REG_VALUE_16BIT},
+{0x408E, 0x008B, AR0830_REG_VALUE_16BIT},
+{0x4090, 0xF007, AR0830_REG_VALUE_16BIT},
+{0x4092, 0x86F0, AR0830_REG_VALUE_16BIT},
+{0x4094, 0x0086, AR0830_REG_VALUE_16BIT},
+{0x4096, 0xF005, AR0830_REG_VALUE_16BIT},
+{0x4098, 0x8080, AR0830_REG_VALUE_16BIT},
+{0x409A, 0x8202, AR0830_REG_VALUE_16BIT},
+{0x409C, 0x0887, AR0830_REG_VALUE_16BIT},
+{0x409E, 0x30C0, AR0830_REG_VALUE_16BIT},
+{0x40A0, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x40A2, 0x3600, AR0830_REG_VALUE_16BIT},
+{0x40A4, 0xF010, AR0830_REG_VALUE_16BIT},
+{0x40A6, 0x3600, AR0830_REG_VALUE_16BIT},
+{0x40A8, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x40AA, 0x30C0, AR0830_REG_VALUE_16BIT},
+{0x40AC, 0x8702, AR0830_REG_VALUE_16BIT},
+{0x40AE, 0x0882, AR0830_REG_VALUE_16BIT},
+{0x40B0, 0x8080, AR0830_REG_VALUE_16BIT},
+{0x40B2, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x40B4, 0x8202, AR0830_REG_VALUE_16BIT},
+{0x40B6, 0x0887, AR0830_REG_VALUE_16BIT},
+{0x40B8, 0x30C0, AR0830_REG_VALUE_16BIT},
+{0x40BA, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x40BC, 0x3600, AR0830_REG_VALUE_16BIT},
+{0x40BE, 0xF00F, AR0830_REG_VALUE_16BIT},
+{0x40C0, 0x3600, AR0830_REG_VALUE_16BIT},
+{0x40C2, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x40C4, 0x30C0, AR0830_REG_VALUE_16BIT},
+{0x40C6, 0x8702, AR0830_REG_VALUE_16BIT},
+{0x40C8, 0x0882, AR0830_REG_VALUE_16BIT},
+{0x40CA, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x40CC, 0x80F0, AR0830_REG_VALUE_16BIT},
+{0x40CE, 0x439F, AR0830_REG_VALUE_16BIT},
+{0x40D0, 0x1300, AR0830_REG_VALUE_16BIT},
+{0x40D2, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x40D4, 0xB7E0, AR0830_REG_VALUE_16BIT},
+{0x40D6, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x40D8, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x40DA, 0x0401, AR0830_REG_VALUE_16BIT},
+{0x40DC, 0xF003, AR0830_REG_VALUE_16BIT},
+{0x40DE, 0x82F0, AR0830_REG_VALUE_16BIT},
+{0x40E0, 0x0302, AR0830_REG_VALUE_16BIT},
+{0x40E2, 0x0885, AR0830_REG_VALUE_16BIT},
+{0x40E4, 0xF015, AR0830_REG_VALUE_16BIT},
+{0x40E6, 0x8587, AR0830_REG_VALUE_16BIT},
+{0x40E8, 0xF033, AR0830_REG_VALUE_16BIT},
+{0x40EA, 0x87F1, AR0830_REG_VALUE_16BIT},
+{0x40EC, 0x8388, AR0830_REG_VALUE_16BIT},
+{0x40EE, 0xF005, AR0830_REG_VALUE_16BIT},
+{0x40F0, 0x88F0, AR0830_REG_VALUE_16BIT},
+{0x40F2, 0x0189, AR0830_REG_VALUE_16BIT},
+{0x40F4, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x40F6, 0x0048, AR0830_REG_VALUE_16BIT},
+{0x40F8, 0xF002, AR0830_REG_VALUE_16BIT},
+{0x40FA, 0x86F0, AR0830_REG_VALUE_16BIT},
+{0x40FC, 0x0482, AR0830_REG_VALUE_16BIT},
+{0x40FE, 0xF017, AR0830_REG_VALUE_16BIT},
+{0x4100, 0x8AF0, AR0830_REG_VALUE_16BIT},
+{0x4102, 0x1780, AR0830_REG_VALUE_16BIT},
+{0x4104, 0xF004, AR0830_REG_VALUE_16BIT},
+{0x4106, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4108, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x410A, 0x0401, AR0830_REG_VALUE_16BIT},
+{0x410C, 0xF015, AR0830_REG_VALUE_16BIT},
+{0x410E, 0x020C, AR0830_REG_VALUE_16BIT},
+{0x4110, 0xF016, AR0830_REG_VALUE_16BIT},
+{0x4112, 0x87F0, AR0830_REG_VALUE_16BIT},
+{0x4114, 0x0287, AR0830_REG_VALUE_16BIT},
+{0x4116, 0xF061, AR0830_REG_VALUE_16BIT},
+{0x4118, 0xE839, AR0830_REG_VALUE_16BIT},
+{0x411A, 0x20F0, AR0830_REG_VALUE_16BIT},
+{0x411C, 0x0534, AR0830_REG_VALUE_16BIT},
+{0x411E, 0x90F0, AR0830_REG_VALUE_16BIT},
+{0x4120, 0x0032, AR0830_REG_VALUE_16BIT},
+{0x4122, 0x48F0, AR0830_REG_VALUE_16BIT},
+{0x4124, 0x0039, AR0830_REG_VALUE_16BIT},
+{0x4126, 0x20F0, AR0830_REG_VALUE_16BIT},
+{0x4128, 0x0E39, AR0830_REG_VALUE_16BIT},
+{0x412A, 0x20F0, AR0830_REG_VALUE_16BIT},
+{0x412C, 0x0032, AR0830_REG_VALUE_16BIT},
+{0x412E, 0x48F0, AR0830_REG_VALUE_16BIT},
+{0x4130, 0x0034, AR0830_REG_VALUE_16BIT},
+{0x4132, 0x90F0, AR0830_REG_VALUE_16BIT},
+{0x4134, 0x05C1, AR0830_REG_VALUE_16BIT},
+{0x4136, 0x1BF0, AR0830_REG_VALUE_16BIT},
+{0x4138, 0x0439, AR0830_REG_VALUE_16BIT},
+{0x413A, 0x20F0, AR0830_REG_VALUE_16BIT},
+{0x413C, 0x03B0, AR0830_REG_VALUE_16BIT},
+{0x413E, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x4140, 0x0208, AR0830_REG_VALUE_16BIT},
+{0x4142, 0xF0AA, AR0830_REG_VALUE_16BIT},
+{0x4144, 0xB0F0, AR0830_REG_VALUE_16BIT},
+{0x4146, 0x1CE9, AR0830_REG_VALUE_16BIT},
+{0x4148, 0x8A00, AR0830_REG_VALUE_16BIT},
+{0x414A, 0x05F0, AR0830_REG_VALUE_16BIT},
+{0x414C, 0x93E0, AR0830_REG_VALUE_16BIT},
+{0x414E, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4150, 0xF063, AR0830_REG_VALUE_16BIT},
+{0x4152, 0x0830, AR0830_REG_VALUE_16BIT},
+{0x4154, 0x0205, AR0830_REG_VALUE_16BIT},
+{0x4156, 0x108F, AR0830_REG_VALUE_16BIT},
+{0x4158, 0x3003, AR0830_REG_VALUE_16BIT},
+{0x415A, 0x92F0, AR0830_REG_VALUE_16BIT},
+{0x415C, 0x0097, AR0830_REG_VALUE_16BIT},
+{0x415E, 0x30D8, AR0830_REG_VALUE_16BIT},
+{0x4160, 0xF007, AR0830_REG_VALUE_16BIT},
+{0x4162, 0x919A, AR0830_REG_VALUE_16BIT},
+{0x4164, 0xF001, AR0830_REG_VALUE_16BIT},
+{0x4166, 0x99F0, AR0830_REG_VALUE_16BIT},
+{0x4168, 0x0285, AR0830_REG_VALUE_16BIT},
+{0x416A, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x416C, 0x30C0, AR0830_REG_VALUE_16BIT},
+{0x416E, 0xF004, AR0830_REG_VALUE_16BIT},
+{0x4170, 0x8B89, AR0830_REG_VALUE_16BIT},
+{0x4172, 0xF007, AR0830_REG_VALUE_16BIT},
+{0x4174, 0x9CF0, AR0830_REG_VALUE_16BIT},
+{0x4176, 0x0082, AR0830_REG_VALUE_16BIT},
+{0x4178, 0x3018, AR0830_REG_VALUE_16BIT},
+{0x417A, 0x8BB1, AR0830_REG_VALUE_16BIT},
+{0x417C, 0xF001, AR0830_REG_VALUE_16BIT},
+{0x417E, 0xB6F0, AR0830_REG_VALUE_16BIT},
+{0x4180, 0x009C, AR0830_REG_VALUE_16BIT},
+{0x4182, 0xF00F, AR0830_REG_VALUE_16BIT},
+{0x4184, 0x99F0, AR0830_REG_VALUE_16BIT},
+{0x4186, 0x0098, AR0830_REG_VALUE_16BIT},
+{0x4188, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x418A, 0x2148, AR0830_REG_VALUE_16BIT},
+{0x418C, 0xF001, AR0830_REG_VALUE_16BIT},
+{0x418E, 0xA2F0, AR0830_REG_VALUE_16BIT},
+{0x4190, 0x03A2, AR0830_REG_VALUE_16BIT},
+{0x4192, 0x96B4, AR0830_REG_VALUE_16BIT},
+{0x4194, 0xF002, AR0830_REG_VALUE_16BIT},
+{0x4196, 0x9DF0, AR0830_REG_VALUE_16BIT},
+{0x4198, 0x04A1, AR0830_REG_VALUE_16BIT},
+{0x419A, 0xF020, AR0830_REG_VALUE_16BIT},
+{0x419C, 0xA1F0, AR0830_REG_VALUE_16BIT},
+{0x419E, 0x049D, AR0830_REG_VALUE_16BIT},
+{0x41A0, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x41A2, 0x8BF0, AR0830_REG_VALUE_16BIT},
+{0x41A4, 0x0010, AR0830_REG_VALUE_16BIT},
+{0x41A6, 0x0983, AR0830_REG_VALUE_16BIT},
+{0x41A8, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x41AA, 0x88F0, AR0830_REG_VALUE_16BIT},
+{0x41AC, 0x0236, AR0830_REG_VALUE_16BIT},
+{0x41AE, 0x00F0, AR0830_REG_VALUE_16BIT},
+{0x41B0, 0x0390, AR0830_REG_VALUE_16BIT},
+{0x41B2, 0x88F0, AR0830_REG_VALUE_16BIT},
+{0x41B4, 0x0436, AR0830_REG_VALUE_16BIT},
+{0x41B6, 0x0083, AR0830_REG_VALUE_16BIT},
+{0x41B8, 0xF013, AR0830_REG_VALUE_16BIT},
+{0x41BA, 0x8BF0, AR0830_REG_VALUE_16BIT},
+{0x41BC, 0x14A3, AR0830_REG_VALUE_16BIT},
+{0x41BE, 0xF003, AR0830_REG_VALUE_16BIT},
+{0x41C0, 0xA3F0, AR0830_REG_VALUE_16BIT},
+{0x41C2, 0x049D, AR0830_REG_VALUE_16BIT},
+{0x41C4, 0xF004, AR0830_REG_VALUE_16BIT},
+{0x41C6, 0xA1F0, AR0830_REG_VALUE_16BIT},
+{0x41C8, 0x20A1, AR0830_REG_VALUE_16BIT},
+{0x41CA, 0xF045, AR0830_REG_VALUE_16BIT},
+{0x41CC, 0x21ED, AR0830_REG_VALUE_16BIT},
+{0x41CE, 0xB440, AR0830_REG_VALUE_16BIT},
+{0x41D0, 0xC284, AR0830_REG_VALUE_16BIT},
+{0x41D2, 0x1FF6, AR0830_REG_VALUE_16BIT},
+{0x41D4, 0x0840, AR0830_REG_VALUE_16BIT},
+{0x41D6, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x41D8, 0x3003, AR0830_REG_VALUE_16BIT},
+{0x41DA, 0x86F0, AR0830_REG_VALUE_16BIT},
+{0x41DC, 0x0080, AR0830_REG_VALUE_16BIT},
+{0x41DE, 0x8082, AR0830_REG_VALUE_16BIT},
+{0x41E0, 0x0208, AR0830_REG_VALUE_16BIT},
+{0x41E2, 0x8736, AR0830_REG_VALUE_16BIT},
+{0x41E4, 0xC0F0, AR0830_REG_VALUE_16BIT},
+{0x41E6, 0x0236, AR0830_REG_VALUE_16BIT},
+{0x41E8, 0xC087, AR0830_REG_VALUE_16BIT},
+{0x41EA, 0x0208, AR0830_REG_VALUE_16BIT},
+{0x41EC, 0x8280, AR0830_REG_VALUE_16BIT},
+{0x41EE, 0x8082, AR0830_REG_VALUE_16BIT},
+{0x41F0, 0x0208, AR0830_REG_VALUE_16BIT},
+{0x41F2, 0x8736, AR0830_REG_VALUE_16BIT},
+{0x41F4, 0xC0F0, AR0830_REG_VALUE_16BIT},
+{0x41F6, 0x0236, AR0830_REG_VALUE_16BIT},
+{0x41F8, 0xC087, AR0830_REG_VALUE_16BIT},
+{0x41FA, 0x0208, AR0830_REG_VALUE_16BIT},
+{0x41FC, 0x8280, AR0830_REG_VALUE_16BIT},
+{0x41FE, 0x8082, AR0830_REG_VALUE_16BIT},
+{0x4200, 0x0208, AR0830_REG_VALUE_16BIT},
+{0x4202, 0x8736, AR0830_REG_VALUE_16BIT},
+{0x4204, 0xC0F0, AR0830_REG_VALUE_16BIT},
+{0x4206, 0x0236, AR0830_REG_VALUE_16BIT},
+{0x4208, 0xC087, AR0830_REG_VALUE_16BIT},
+{0x420A, 0x0208, AR0830_REG_VALUE_16BIT},
+{0x420C, 0x8280, AR0830_REG_VALUE_16BIT},
+{0x420E, 0x8082, AR0830_REG_VALUE_16BIT},
+{0x4210, 0x0208, AR0830_REG_VALUE_16BIT},
+{0x4212, 0x8736, AR0830_REG_VALUE_16BIT},
+{0x4214, 0xC0F0, AR0830_REG_VALUE_16BIT},
+{0x4216, 0x0236, AR0830_REG_VALUE_16BIT},
+{0x4218, 0xC087, AR0830_REG_VALUE_16BIT},
+{0x421A, 0x9F13, AR0830_REG_VALUE_16BIT},
+{0x421C, 0x0002, AR0830_REG_VALUE_16BIT},
+{0x421E, 0x0DB7, AR0830_REG_VALUE_16BIT},
+{0x4220, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4222, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4224, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4226, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4228, 0xF013, AR0830_REG_VALUE_16BIT},
+{0x422A, 0x80F0, AR0830_REG_VALUE_16BIT},
+{0x422C, 0x3102, AR0830_REG_VALUE_16BIT},
+{0x422E, 0x3410, AR0830_REG_VALUE_16BIT},
+{0x4230, 0xCF30, AR0830_REG_VALUE_16BIT},
+{0x4232, 0x03F0, AR0830_REG_VALUE_16BIT},
+{0x4234, 0x00B2, AR0830_REG_VALUE_16BIT},
+{0x4236, 0x30C0, AR0830_REG_VALUE_16BIT},
+{0x4238, 0x3018, AR0830_REG_VALUE_16BIT},
+{0x423A, 0x97B5, AR0830_REG_VALUE_16BIT},
+{0x423C, 0xF004, AR0830_REG_VALUE_16BIT},
+{0x423E, 0x91F0, AR0830_REG_VALUE_16BIT},
+{0x4240, 0x009A, AR0830_REG_VALUE_16BIT},
+{0x4242, 0xF001, AR0830_REG_VALUE_16BIT},
+{0x4244, 0x99F0, AR0830_REG_VALUE_16BIT},
+{0x4246, 0x0330, AR0830_REG_VALUE_16BIT},
+{0x4248, 0x18F0, AR0830_REG_VALUE_16BIT},
+{0x424A, 0x0085, AR0830_REG_VALUE_16BIT},
+{0x424C, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x424E, 0x30C0, AR0830_REG_VALUE_16BIT},
+{0x4250, 0x9E40, AR0830_REG_VALUE_16BIT},
+{0x4252, 0x4220, AR0830_REG_VALUE_16BIT},
+{0x4254, 0x1889, AR0830_REG_VALUE_16BIT},
+{0x4256, 0x4104, AR0830_REG_VALUE_16BIT},
+{0x4258, 0x82A0, AR0830_REG_VALUE_16BIT},
+{0x425A, 0xF002, AR0830_REG_VALUE_16BIT},
+{0x425C, 0x8B9C, AR0830_REG_VALUE_16BIT},
+{0x425E, 0xF010, AR0830_REG_VALUE_16BIT},
+{0x4260, 0x99F0, AR0830_REG_VALUE_16BIT},
+{0x4262, 0x0098, AR0830_REG_VALUE_16BIT},
+{0x4264, 0xF003, AR0830_REG_VALUE_16BIT},
+{0x4266, 0xA296, AR0830_REG_VALUE_16BIT},
+{0x4268, 0xF001, AR0830_REG_VALUE_16BIT},
+{0x426A, 0xB4A2, AR0830_REG_VALUE_16BIT},
+{0x426C, 0xF004, AR0830_REG_VALUE_16BIT},
+{0x426E, 0x9DF0, AR0830_REG_VALUE_16BIT},
+{0x4270, 0x04A1, AR0830_REG_VALUE_16BIT},
+{0x4272, 0xF028, AR0830_REG_VALUE_16BIT},
+{0x4274, 0x8BA1, AR0830_REG_VALUE_16BIT},
+{0x4276, 0x1009, AR0830_REG_VALUE_16BIT},
+{0x4278, 0x83F0, AR0830_REG_VALUE_16BIT},
+{0x427A, 0x0136, AR0830_REG_VALUE_16BIT},
+{0x427C, 0x00F0, AR0830_REG_VALUE_16BIT},
+{0x427E, 0x009D, AR0830_REG_VALUE_16BIT},
+{0x4280, 0x88F0, AR0830_REG_VALUE_16BIT},
+{0x4282, 0x0888, AR0830_REG_VALUE_16BIT},
+{0x4284, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x4286, 0x3600, AR0830_REG_VALUE_16BIT},
+{0x4288, 0x8390, AR0830_REG_VALUE_16BIT},
+{0x428A, 0xF096, AR0830_REG_VALUE_16BIT},
+{0x428C, 0x8BF0, AR0830_REG_VALUE_16BIT},
+{0x428E, 0x0CA3, AR0830_REG_VALUE_16BIT},
+{0x4290, 0xF003, AR0830_REG_VALUE_16BIT},
+{0x4292, 0xA3F0, AR0830_REG_VALUE_16BIT},
+{0x4294, 0x049D, AR0830_REG_VALUE_16BIT},
+{0x4296, 0xF004, AR0830_REG_VALUE_16BIT},
+{0x4298, 0xA1F0, AR0830_REG_VALUE_16BIT},
+{0x429A, 0x20A1, AR0830_REG_VALUE_16BIT},
+{0x429C, 0xF043, AR0830_REG_VALUE_16BIT},
+{0x429E, 0x9DB4, AR0830_REG_VALUE_16BIT},
+{0x42A0, 0xF015, AR0830_REG_VALUE_16BIT},
+{0x42A2, 0x8B91, AR0830_REG_VALUE_16BIT},
+{0x42A4, 0x848E, AR0830_REG_VALUE_16BIT},
+{0x42A6, 0xF01E, AR0830_REG_VALUE_16BIT},
+{0x42A8, 0xB8F1, AR0830_REG_VALUE_16BIT},
+{0x42AA, 0xB3B2, AR0830_REG_VALUE_16BIT},
+{0x42AC, 0xF060, AR0830_REG_VALUE_16BIT},
+{0x42AE, 0xA6B9, AR0830_REG_VALUE_16BIT},
+{0x42B0, 0x848E, AR0830_REG_VALUE_16BIT},
+{0x42B2, 0xF004, AR0830_REG_VALUE_16BIT},
+{0x42B4, 0x0202, AR0830_REG_VALUE_16BIT},
+{0x42B6, 0xF015, AR0830_REG_VALUE_16BIT},
+{0x42B8, 0xB2F0, AR0830_REG_VALUE_16BIT},
+{0x42BA, 0x0691, AR0830_REG_VALUE_16BIT},
+{0x42BC, 0x83B8, AR0830_REG_VALUE_16BIT},
+{0x42BE, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x42C0, 0x3600, AR0830_REG_VALUE_16BIT},
+{0x42C2, 0xF00D, AR0830_REG_VALUE_16BIT},
+{0x42C4, 0x3600, AR0830_REG_VALUE_16BIT},
+{0x42C6, 0x83F0, AR0830_REG_VALUE_16BIT},
+{0x42C8, 0x029C, AR0830_REG_VALUE_16BIT},
+{0x42CA, 0xF008, AR0830_REG_VALUE_16BIT},
+{0x42CC, 0x9CF0, AR0830_REG_VALUE_16BIT},
+{0x42CE, 0x128B, AR0830_REG_VALUE_16BIT},
+{0x42D0, 0xF006, AR0830_REG_VALUE_16BIT},
+{0x42D2, 0x3018, AR0830_REG_VALUE_16BIT},
+{0x42D4, 0xA3F0, AR0830_REG_VALUE_16BIT},
+{0x42D6, 0x04A3, AR0830_REG_VALUE_16BIT},
+{0x42D8, 0xF003, AR0830_REG_VALUE_16BIT},
+{0x42DA, 0x9DF0, AR0830_REG_VALUE_16BIT},
+{0x42DC, 0x6A30, AR0830_REG_VALUE_16BIT},
+{0x42DE, 0x189D, AR0830_REG_VALUE_16BIT},
+{0x42E0, 0xF002, AR0830_REG_VALUE_16BIT},
+{0x42E2, 0x8BF0, AR0830_REG_VALUE_16BIT},
+{0x42E4, 0x0082, AR0830_REG_VALUE_16BIT},
+{0x42E6, 0xF004, AR0830_REG_VALUE_16BIT},
+{0x42E8, 0x30C0, AR0830_REG_VALUE_16BIT},
+{0x42EA, 0xF014, AR0830_REG_VALUE_16BIT},
+{0x42EC, 0x30C0, AR0830_REG_VALUE_16BIT},
+{0x42EE, 0xF004, AR0830_REG_VALUE_16BIT},
+{0x42F0, 0x82F0, AR0830_REG_VALUE_16BIT},
+{0x42F2, 0x0D90, AR0830_REG_VALUE_16BIT},
+{0x42F4, 0xF002, AR0830_REG_VALUE_16BIT},
+{0x42F6, 0x8BF0, AR0830_REG_VALUE_16BIT},
+{0x42F8, 0x018C, AR0830_REG_VALUE_16BIT},
+{0x42FA, 0x8FF0, AR0830_REG_VALUE_16BIT},
+{0x42FC, 0x3E30, AR0830_REG_VALUE_16BIT},
+{0x42FE, 0x18A2, AR0830_REG_VALUE_16BIT},
+{0x4300, 0xF003, AR0830_REG_VALUE_16BIT},
+{0x4302, 0xA2F0, AR0830_REG_VALUE_16BIT},
+{0x4304, 0x049D, AR0830_REG_VALUE_16BIT},
+{0x4306, 0xF036, AR0830_REG_VALUE_16BIT},
+{0x4308, 0x9DF0, AR0830_REG_VALUE_16BIT},
+{0x430A, 0x0A30, AR0830_REG_VALUE_16BIT},
+{0x430C, 0x1889, AR0830_REG_VALUE_16BIT},
+{0x430E, 0xB5F0, AR0830_REG_VALUE_16BIT},
+{0x4310, 0x018B, AR0830_REG_VALUE_16BIT},
+{0x4312, 0xF002, AR0830_REG_VALUE_16BIT},
+{0x4314, 0x97F0, AR0830_REG_VALUE_16BIT},
+{0x4316, 0x0017, AR0830_REG_VALUE_16BIT},
+{0x4318, 0xA621, AR0830_REG_VALUE_16BIT},
+{0x431A, 0xCD40, AR0830_REG_VALUE_16BIT},
+{0x431C, 0xC230, AR0830_REG_VALUE_16BIT},
+{0x431E, 0x0710, AR0830_REG_VALUE_16BIT},
+{0x4320, 0x4984, AR0830_REG_VALUE_16BIT},
+{0x4322, 0xF00C, AR0830_REG_VALUE_16BIT},
+{0x4324, 0x80F0, AR0830_REG_VALUE_16BIT},
+{0x4326, 0x1486, AR0830_REG_VALUE_16BIT},
+{0x4328, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x432A, 0x86F0, AR0830_REG_VALUE_16BIT},
+{0x432C, 0x0C80, AR0830_REG_VALUE_16BIT},
+{0x432E, 0x8283, AR0830_REG_VALUE_16BIT},
+{0x4330, 0x8730, AR0830_REG_VALUE_16BIT},
+{0x4332, 0xC036, AR0830_REG_VALUE_16BIT},
+{0x4334, 0x00F0, AR0830_REG_VALUE_16BIT},
+{0x4336, 0x1030, AR0830_REG_VALUE_16BIT},
+{0x4338, 0xC036, AR0830_REG_VALUE_16BIT},
+{0x433A, 0x0087, AR0830_REG_VALUE_16BIT},
+{0x433C, 0x8382, AR0830_REG_VALUE_16BIT},
+{0x433E, 0x8080, AR0830_REG_VALUE_16BIT},
+{0x4340, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x4342, 0x8283, AR0830_REG_VALUE_16BIT},
+{0x4344, 0x8730, AR0830_REG_VALUE_16BIT},
+{0x4346, 0xC036, AR0830_REG_VALUE_16BIT},
+{0x4348, 0x00F0, AR0830_REG_VALUE_16BIT},
+{0x434A, 0x0F30, AR0830_REG_VALUE_16BIT},
+{0x434C, 0xC0F0, AR0830_REG_VALUE_16BIT},
+{0x434E, 0x0036, AR0830_REG_VALUE_16BIT},
+{0x4350, 0x0087, AR0830_REG_VALUE_16BIT},
+{0x4352, 0x8382, AR0830_REG_VALUE_16BIT},
+{0x4354, 0xF000, AR0830_REG_VALUE_16BIT},
+{0x4356, 0x80F1, AR0830_REG_VALUE_16BIT},
+{0x4358, 0xD9B8, AR0830_REG_VALUE_16BIT},
+{0x435A, 0xF00D, AR0830_REG_VALUE_16BIT},
+{0x435C, 0xB7F0, AR0830_REG_VALUE_16BIT},
+{0x435E, 0x019F, AR0830_REG_VALUE_16BIT},
+{0x4360, 0xF02B, AR0830_REG_VALUE_16BIT},
+{0x4362, 0x1300, AR0830_REG_VALUE_16BIT},
+{0x4364, 0xB981, AR0830_REG_VALUE_16BIT},
+{0x4366, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4368, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x436A, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x436C, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x436E, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4370, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4372, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4374, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4376, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4378, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x437A, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x437C, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x437E, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4380, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4382, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4384, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4386, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4388, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x438A, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x438C, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x438E, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4390, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4392, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4394, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4396, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4398, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x439A, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x439C, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x439E, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43A0, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43A2, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43A4, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43A6, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43A8, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43AA, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43AC, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43AE, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43B0, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43B2, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43B4, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43B6, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43B8, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43BA, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43BC, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43BE, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43C0, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43C2, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43C4, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43C6, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43C8, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43CA, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43CC, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43CE, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43D0, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43D2, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43D4, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43D6, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43D8, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43DA, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43DC, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43DE, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43E0, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43E2, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43E4, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43E6, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43E8, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43EA, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43EC, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43EE, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43F0, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43F2, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43F4, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43F6, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43F8, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43FA, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43FC, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x43FE, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4400, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4402, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4404, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4406, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4408, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x440A, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x440C, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x440E, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4410, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4412, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4414, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4416, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4418, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x441A, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x441C, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x441E, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4420, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4422, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4424, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4426, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4428, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x442A, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x442C, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x442E, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4430, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4432, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4434, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4436, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4438, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x443A, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x443C, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x443E, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4440, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4442, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4444, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4446, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4448, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x444A, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x444C, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x444E, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4450, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4452, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4454, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4456, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4458, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x445A, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x445C, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x445E, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4460, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4462, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4464, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4466, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4468, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x446A, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x446C, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x446E, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4470, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4472, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4474, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4476, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4478, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x447A, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x447C, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x447E, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4480, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4482, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4484, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4486, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4488, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x448A, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x448C, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x448E, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4490, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4492, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4494, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4496, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x4498, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x449A, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x449C, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x449E, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x44A0, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x44A2, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x44A4, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x44A6, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x44A8, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x44AA, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x44AC, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x44AE, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x44B0, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x44B2, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x44B4, 0xE0E0, AR0830_REG_VALUE_16BIT},
+{0x3980, 0x0001, AR0830_REG_VALUE_16BIT},
+{0x3340, 0x0C60, AR0830_REG_VALUE_16BIT},
+{0x3F7C, 0x0001, AR0830_REG_VALUE_16BIT},
+{0x0344, 0x0008, AR0830_REG_VALUE_16BIT},
+{0x0348, 0x0F07, AR0830_REG_VALUE_16BIT},
+{0x0346, 0x0008, AR0830_REG_VALUE_16BIT},
+{0x034A, 0x0877, AR0830_REG_VALUE_16BIT},
+{0x034C, 0x0F00, AR0830_REG_VALUE_16BIT},
+{0x034E, 0x0870, AR0830_REG_VALUE_16BIT},
+{0x0380, 0x0001, AR0830_REG_VALUE_16BIT},
+{0x0382, 0x0001, AR0830_REG_VALUE_16BIT},
+{0x0384, 0x0001, AR0830_REG_VALUE_16BIT},
+{0x0386, 0x0001, AR0830_REG_VALUE_16BIT},
+{0x0900, 0x00  , AR0830_REG_VALUE_08BIT},
+{0x0901, 0x11  , AR0830_REG_VALUE_08BIT},
+{0x0342, 0x2340, AR0830_REG_VALUE_16BIT},
+{0x0340, 0x08A8, AR0830_REG_VALUE_16BIT},
+{0x0202, 0x0884, AR0830_REG_VALUE_16BIT},
+{0x020E, 0x0100, AR0830_REG_VALUE_16BIT},
+{0x0204, 0x0000, AR0830_REG_VALUE_16BIT},
+{0x0112, 0x0A0A, AR0830_REG_VALUE_16BIT},
+{0x3EC4, 0x0204, AR0830_REG_VALUE_16BIT},
+{0x3EC6, 0x0000, AR0830_REG_VALUE_16BIT},
+{0x3600, 0x94D8, AR0830_REG_VALUE_16BIT},
+{0x5500, 0x0000, AR0830_REG_VALUE_16BIT},
+{0x5502, 0x0001, AR0830_REG_VALUE_16BIT},
+{0x5504, 0x0006, AR0830_REG_VALUE_16BIT},
+{0x5506, 0x0008, AR0830_REG_VALUE_16BIT},
+{0x5508, 0x000F, AR0830_REG_VALUE_16BIT},
+{0x550A, 0x0010, AR0830_REG_VALUE_16BIT},
+{0x550C, 0x0011, AR0830_REG_VALUE_16BIT},
+{0x550E, 0x0012, AR0830_REG_VALUE_16BIT},
+{0x5510, 0x0016, AR0830_REG_VALUE_16BIT},
+{0x5512, 0x0018, AR0830_REG_VALUE_16BIT},
+{0x5514, 0x0021, AR0830_REG_VALUE_16BIT},
+{0x5516, 0x0023, AR0830_REG_VALUE_16BIT},
+{0x5518, 0x0026, AR0830_REG_VALUE_16BIT},
+{0x551A, 0x0028, AR0830_REG_VALUE_16BIT},
+{0x551C, 0x002F, AR0830_REG_VALUE_16BIT},
+{0x551E, 0x0030, AR0830_REG_VALUE_16BIT},
+{0x5400, 0x0100, AR0830_REG_VALUE_16BIT},
+{0x5402, 0x2106, AR0830_REG_VALUE_16BIT},
+{0x5404, 0x1103, AR0830_REG_VALUE_16BIT},
+{0x5406, 0x3103, AR0830_REG_VALUE_16BIT},
+{0x5408, 0x6103, AR0830_REG_VALUE_16BIT},
+{0x540A, 0x9103, AR0830_REG_VALUE_16BIT},
+{0x540C, 0xA103, AR0830_REG_VALUE_16BIT},
+{0x540E, 0xD103, AR0830_REG_VALUE_16BIT},
+{0x5410, 0xF110, AR0830_REG_VALUE_16BIT},
+{0x5412, 0xE102, AR0830_REG_VALUE_16BIT},
+{0x5414, 0xF15E, AR0830_REG_VALUE_16BIT},
+{0x5416, 0xF1EE, AR0830_REG_VALUE_16BIT},
+{0x5418, 0xF2BA, AR0830_REG_VALUE_16BIT},
+{0x541A, 0xF3DA, AR0830_REG_VALUE_16BIT},
+{0x541C, 0xF571, AR0830_REG_VALUE_16BIT},
+{0x541E, 0xF7B0, AR0830_REG_VALUE_16BIT},
+{0x5420, 0xFADD, AR0830_REG_VALUE_16BIT},
+{0x5422, 0xFF58, AR0830_REG_VALUE_16BIT},
+{0x5424, 0xFFFA, AR0830_REG_VALUE_16BIT},
+{0x5426, 0x5557, AR0830_REG_VALUE_16BIT},
+{0x5428, 0x0005, AR0830_REG_VALUE_16BIT},
+{0x542A, 0xA550, AR0830_REG_VALUE_16BIT},
+{0x542C, 0xAAAA, AR0830_REG_VALUE_16BIT},
+{0x542E, 0x000A, AR0830_REG_VALUE_16BIT},
+{0x5460, 0x2269, AR0830_REG_VALUE_16BIT},
+{0x5462, 0x0B8F, AR0830_REG_VALUE_16BIT},
+{0x5464, 0x0B8F, AR0830_REG_VALUE_16BIT},
+{0x5466, 0x098B, AR0830_REG_VALUE_16BIT},
+{0x5498, 0x2263, AR0830_REG_VALUE_16BIT},
+{0x549A, 0x54E2, AR0830_REG_VALUE_16BIT},
+{0x549C, 0x54E3, AR0830_REG_VALUE_16BIT},
+{0x549E, 0x54E3, AR0830_REG_VALUE_16BIT},
+{0x3060, 0xFF01, AR0830_REG_VALUE_16BIT},
+{REG_DELAY, 200},
+};
+
+#endif
diff --git a/vvcam/version/BUILD.bazel b/vvcam/version/BUILD.bazel
index f6f19e0..e52e2ed 100644
--- a/vvcam/version/BUILD.bazel
+++ b/vvcam/version/BUILD.bazel
@@ -8,5 +8,6 @@ filegroup(
         "//verisilicon_sw_isp_vvcam/vvcam/v4l2/dwe:__subpackages__",
         "//verisilicon_sw_isp_vvcam/vvcam/v4l2/isp:__subpackages__",
         "//verisilicon_sw_isp_vvcam/vvcam/v4l2/sensor/os08a20:__subpackages__",
+        "//verisilicon_sw_isp_vvcam/vvcam/v4l2/sensor/ar0830:__subpackages__",
     ],
 )
diff --git a/vvcam/vvcam.mk b/vvcam/vvcam.mk
index 7669948..f4206cb 100644
--- a/vvcam/vvcam.mk
+++ b/vvcam/vvcam.mk
@@ -31,6 +31,7 @@ vvcam: $(VVCAM_KERNELENVSH) $(VVCAM_SRC_PATH)
 	cp $(VVCAM_SRC_PATH)/sensor/ov2775/ov2775.ko $(VVCAM_OUT);
 	cp $(VVCAM_SRC_PATH)/sensor/camera-proxy-driver/basler-camera-driver-vvcam.ko $(VVCAM_OUT);
 	cp $(VVCAM_SRC_PATH)/sensor/os08a20/os08a20.ko $(VVCAM_OUT);
+	cp $(VVCAM_SRC_PATH)/sensor/ar0830/ar0830.ko $(VVCAM_OUT);
 	cp $(VVCAM_SRC_PATH)/video/vvcam-video.ko $(VVCAM_OUT);
 	cp $(VVCAM_SRC_PATH)/isp/vvcam-isp.ko $(VVCAM_OUT);
 	cp $(VVCAM_SRC_PATH)/dwe/vvcam-dwe.ko $(VVCAM_OUT);
-- 
2.34.1

